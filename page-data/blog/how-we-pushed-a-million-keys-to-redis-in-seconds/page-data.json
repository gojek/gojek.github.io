{"componentChunkName":"component---src-templates-post-js","path":"/blog/how-we-pushed-a-million-keys-to-redis-in-seconds/","result":{"data":{"ghostPost":{"id":"Ghost__Post__5eafa30734df85001e15f489","title":"How We Pushed a Million Keys to Redis in Seconds","slug":"how-we-pushed-a-million-keys-to-redis-in-seconds","featured":false,"feature_image":"https://res-2.cloudinary.com/hcq4cvthp/image/upload/q_auto/v1/ghost-blog-images/1_gN5KGQcKSipjSlQqEppJMA.jpg","excerpt":"Dealing with a lot of keys? Redis’ Pipe Mode is your friend.\nHello there!\n\nIn this post, I’ll share my ideas on how we populated Redis (running in a\nKubernetes cluster)… in a matter of seconds.\n\nHere’s what can you expect from this post:\n\n1. How to connect to Redis server running in a Kubernetes cluster ?\n\n2. What is Port-forwarding ?\n\n3. How to use Redis mass insertion & push millions of keys in seconds ?\n\n4. How to generate Redis Protocol ?\n\n5. How to read /parse a CSV in Ruby ?\n\nWait, but why","custom_excerpt":null,"visibility":"public","created_at_pretty":"04 May, 2020","published_at_pretty":"04 May, 2020","updated_at_pretty":"12 May, 2020","created_at":"2020-05-04T10:37:19.000+05:30","published_at":"2020-05-04T10:45:13.000+05:30","updated_at":"2020-05-12T11:50:45.000+05:30","meta_title":"How We Pushed a Million Keys to Redis in Seconds","meta_description":"Dealing with a lot of keys? Redis’ Pipe Mode is your friend.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Gojek","slug":"gojek","bio":"Gojek is a Super App. It’s one app for ordering food, commuting, digital payments, shopping, hyper-local delivery, and two dozen services.","profile_image":"https://gojek-ghost.zysk.in/content/images/2020/05/logo-01-1.png","twitter":"@gojektech","facebook":"gojektech","website":"https://www.gojek.io"}],"primary_author":{"name":"Gojek","slug":"gojek","bio":"Gojek is a Super App. It’s one app for ordering food, commuting, digital payments, shopping, hyper-local delivery, and two dozen services.","profile_image":"https://gojek-ghost.zysk.in/content/images/2020/05/logo-01-1.png","twitter":"@gojektech","facebook":"gojektech","website":"https://www.gojek.io"},"primary_tag":{"name":"Tech","slug":"tech","description":"Learnings from technical challenges solved at Gojek, how-tos, and programming tips.","feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Tech","slug":"tech","description":"Learnings from technical challenges solved at Gojek, how-tos, and programming tips.","feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Dealing with a lot of keys? Redis’ Pipe Mode is your friend.\nHello there!\n\nIn this post, I’ll share my ideas on how we populated Redis (running in a\nKubernetes cluster)… in a matter of seconds.\n\nHere’s what can you expect from this post:\n\n1. How to connect to Redis server running in a Kubernetes cluster ?\n\n2. What is Port-forwarding ?\n\n3. How to use Redis mass insertion & push millions of keys in seconds ?\n\n4. How to generate Redis Protocol ?\n\n5. How to read /parse a CSV in Ruby ?\n\nWait, but why do I need to do this? ?\n\nAt Gojek, we use Redis in one of the services for caching drivers for faster\nlookups. Since we have deployed this service to new clusters, we needed to\npopulate Redis with ~81K keys.\n\nWhat we didn’t do (and should not be done)\nWell, this. ?\n\n$ redis-cli -h \"hostname\" -p 6379 set \"key\" \"value\"\n\nThis simple and easy way of storing a key through redis-cli\n[https://redis.io/topics/rediscli] is okay, but not for thousands or millions of\nkeys. You don’t want to end up waiting for hours unless you are Regina Phalange\n[https://en.wikipedia.org/wiki/Phoebe_Buffay#%22Regina_Phalange%22]! ?\n\nUsing a normal Redis client to perform mass insertion is not a good idea. The\nnaive approach of sending one command after the other is slow, because you have\nto pay for the round trip time for every command.\n\nLet’s do something different!\nWe will use Redis mass insertion, but before going to that, let’s talk a bit\nabout Redis Protocol [https://redis.io/topics/protocol].\n\nRedis clients communicate with the Redis server using a protocol called RESP \n(REdis Serialization Protocol).\n\nWith that said, let’s go write some code! I like toying around with Ruby\n[https://www.ruby-lang.org/en/], so this was my language of choice.\n\nredis_mass_insert.rbgen_redis_proto function will generate the protocol required for mass insertion.\n\n> 2.6.3 > puts gen_redis_proto(\"SET\",\"mykey\",\"Hello World!\").inspect\nRunning the above command in Ruby console, will give us the following protocol.\n\n\"*3\\r\\n$3\\r\\nSET\\r\\n$5\\r\\nmykey\\r\\n$12\\r\\nHello World!\\r\\n\"\n\nWell, this is how a command is represented and sent to the Redis Server through \nRedis Protocol [https://redis.io/topics/protocol].\n\n*<args><cr><lf>\n$<len><cr><lf>\n<arg0><cr><lf>\n<arg1><cr><lf>\n...\n<argN><cr><lf>\n\nWhere <cr> means \"\\r\" (or ASCII character 13) and <lf> means \"\\n\" (or ASCII\ncharacter 10).\n\nWe can now run this script, but here’s a catch. Our Redis server runs in a\nKubernetes cluster and we didn’t want to install Ruby and its gems inside a\ncluster. So now?\n\nEnter port-forwarding! ?\n$ kubectl -n \"namespace\" port-forward \"pod-name\" 7000:6379\n\nConnections made to local port 7000 are forwarded to port 6379 of the pod that\nis running the Redis server. With this connection in place we can use our local\nworkstation to debug the database that is running in the pod.\n\nFinally, we run our script to populate Redis ?\n\n> $ ruby redis_mass_insert.rb | redis-cli -p 7000 --pipe\n> All data transferred. Waiting for the last reply...\nLast reply received from server.\nerrors: 0, replies: 81003\nWe ran this script and it completed within a fraction of seconds!\n\nBut, how?\nIn 2.6 or later versions of Redis the redis-cli utility supports a new mode\ncalled pipe mode that was designed in order to perform mass insertion.\n\nUnder the hood of pipe mode\nAccording to the official doc:\n\n * redis-cli — pipe tries to send data as fast as possible to the server.\n * At the same time it reads data when available, trying to parse it.\n * Once there is no more data to read from stdin, it sends a special ECHO \n   command with a random 20 bytes string: we are sure this is the latest command\n   sent, and we are sure we can match the reply checking if we receive the same\n   20 bytes as a bulk reply.\n * Once this special final command is sent, the code receiving replies starts to\n   match replies with these 20 bytes. When the matching reply is reached it can\n   exit with success.\n\nNaice, what’s next?\nWell, I tried populating Redis locally with a million keys.\n\nIt worked like a charm, in just ~2 seconds. ?\n\nThat’s it!\nI really hope that this post gave you some new insights.\n\nThanks for reading! ?\n\nReferences\n\n 1. Redis Mass Insertion [https://redis.io/topics/mass-insert]\n 2. Redis Protocol [https://redis.io/topics/protocol]\n 3. Port Forwarding in Kubernetes to access applications\n    [https://kubernetes.io/docs/tasks/access-application-cluster/port-forward-access-application-cluster/]\n\nWant our stories to land in your inbox? Sign up for our newsletter!\n[https://mailchi.mp/go-jek/gojek-tech-newsletter]","html":"<h3 id=\"dealing-with-a-lot-of-keys-redis-pipe-mode-is-your-friend-\">Dealing with a lot of keys? Redis’ Pipe Mode is your friend.</h3><p>Hello there!</p><p>In this post, I’ll share my ideas on how we populated Redis (running in a Kubernetes cluster)… in a matter of seconds.</p><p>Here’s what can you expect from this post:</p><p><em><em>1. How to connect to Redis server running in a Kubernetes cluster ?</em></em></p><p><em><em>2. What is Port-forwarding ?</em></em></p><p><em><em>3. How to use Redis mass insertion &amp; push millions of keys in seconds ?</em></em></p><p><em><em>4. How to generate Redis Protocol ?</em></em></p><p><em><em>5. How to read /parse a CSV in Ruby ?</em></em></p><p>Wait, but why do I need to do this? ?</p><p>At Gojek, we use Redis in one of the services for caching drivers for faster lookups. Since we have deployed this service to new clusters, we needed to populate Redis with ~81K keys.</p><h2 id=\"what-we-didn-t-do-and-should-not-be-done-\">What we didn’t do (and should not be done)</h2><p>Well, this. ?</p><p><code>$ redis-cli -h \"hostname\" -p 6379 set \"key\" \"value\"</code></p><p>This simple and easy way of storing a key through <code><a href=\"https://redis.io/topics/rediscli\" rel=\"noopener\">redis-cli</a></code> is okay, but not for thousands or millions of keys. You don’t want to end up waiting for hours unless you are <a href=\"https://en.wikipedia.org/wiki/Phoebe_Buffay#%22Regina_Phalange%22\" rel=\"noopener\">Regina Phalange</a>! ?</p><figure class=\"kg-card kg-embed-card\"><iframe src=\"https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fgiphy.com%2Fembed%2F5xaOcLvROln5TmaaVOM%2Ftwitter%2Fiframe&amp;display_name=Giphy&amp;url=https%3A%2F%2Fgiphy.com%2Fgifs%2Fthecomebackhbo-comeback-the-val-cherish-5xaOcLvROln5TmaaVOM&amp;image=https%3A%2F%2Fmedia.giphy.com%2Fmedia%2F5xaOcLvROln5TmaaVOM%2Fgiphy.gif&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=giphy\" allowfullscreen=\"\" frameborder=\"0\" height=\"301\" width=\"435\" title=\"Lisa Kudrow Thank You GIF by The Comeback HBO - Find &amp; Share on GIPHY\" class=\"s t u iu ai\" scrolling=\"auto\" style=\"box-sizing: inherit; position: absolute; top: 0px; left: 0px; width: 680px; height: 470.516px;\"></iframe></figure><p>Using a normal Redis client to perform mass insertion is not a good idea. The naive approach of sending one command after the other is slow, because you have to pay for the round trip time for every command.</p><h1 id=\"let-s-do-something-different-\">Let’s do something different!</h1><p>We will use Redis mass insertion, but before going to that, let’s talk a bit about <a href=\"https://redis.io/topics/protocol\" rel=\"noopener\">Redis Protocol</a>.</p><p><em><em>Redis clients communicate with the Redis server using a protocol called <strong><strong>RESP</strong></strong> (REdis Serialization Protocol).</em></em></p><p>With that said, let’s go write some code! I like toying around with <a href=\"https://www.ruby-lang.org/en/\" rel=\"noopener\">Ruby</a>, so this was my language of choice.</p><figure class=\"kg-card kg-embed-card kg-card-hascaption\"><iframe src=\"https://blog.gojekengineering.com/media/59319951b0d29feee60832a68f811a18\" allowfullscreen=\"\" frameborder=\"0\" height=\"364\" width=\"680\" title=\"Ruby Script for Redis Mass Insertion\" class=\"s t u iu ai\" scrolling=\"auto\" style=\"box-sizing: inherit; position: absolute; top: 0px; left: 0px; width: 680px; height: 364px;\"></iframe><figcaption>redis_mass_insert.rb</figcaption></figure><p><code>gen_redis_proto</code> function will generate the protocol required for mass insertion.</p><blockquote>2.6.3 &gt; <strong><strong>puts gen_redis_proto(\"SET\",\"mykey\",\"Hello World!\").inspect</strong></strong></blockquote><p>Running the above command in Ruby console, will give us the following protocol.</p><p><code>\"*3\\r\\n$3\\r\\nSET\\r\\n$5\\r\\nmykey\\r\\n$12\\r\\nHello World!\\r\\n\"</code></p><p>Well, this is how a command is represented and sent to the Redis Server through <a href=\"https://redis.io/topics/protocol\" rel=\"noopener\">Redis Protocol</a>.</p><p><code>*&lt;args&gt;&lt;cr&gt;&lt;lf&gt;<br>$&lt;len&gt;&lt;cr&gt;&lt;lf&gt;<br>&lt;arg0&gt;&lt;cr&gt;&lt;lf&gt;<br>&lt;arg1&gt;&lt;cr&gt;&lt;lf&gt;<br>...<br>&lt;argN&gt;&lt;cr&gt;&lt;lf&gt;</code></p><p><em><em>Where <code>&lt;cr&gt;</code> means \"\\r\" (or ASCII character 13) and <code>&lt;lf&gt;</code> means \"\\n\" (or ASCII character 10).</em></em></p><p>We can now run this script, but here’s a catch. Our Redis server runs in a Kubernetes cluster and we didn’t want to install Ruby and its gems inside a cluster. So now?</p><h1 id=\"enter-port-forwarding-\">Enter port-forwarding! ?</h1><p><strong><strong><code>$ kubectl -n \"namespace\" port-forward \"pod-name\" 7000:6379</code></strong></strong></p><p>Connections made to local port 7000 are forwarded to port 6379 of the pod that is running the Redis server. With this connection in place we can use our local workstation to debug the database that is running in the pod.</p><p><em><em><em>Finally, we run our script to populate Redis ?</em></em></em></p><blockquote><strong><strong>$ ruby redis_mass_insert.rb | redis-cli -p 7000 --pipe</strong></strong></blockquote><blockquote>All data transferred. Waiting for the last reply...<br>Last reply received from server.<br>errors: 0, replies: 81003</blockquote><p>We ran this script and it completed within a fraction of seconds!</p><figure class=\"kg-card kg-embed-card\"><iframe src=\"https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fgiphy.com%2Fembed%2FjRARA4zqym98KmvkUy%2Ftwitter%2Fiframe&amp;display_name=Giphy&amp;url=https%3A%2F%2Fgiphy.com%2Fgifs%2FjRARA4zqym98KmvkUy&amp;image=https%3A%2F%2Fmedia.giphy.com%2Fmedia%2FjRARA4zqym98KmvkUy%2Fgiphy.gif&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=giphy\" allowfullscreen=\"\" frameborder=\"0\" height=\"246\" width=\"435\" title=\"Bingo GIF - Find &amp; Share on GIPHY\" class=\"s t u iu ai\" scrolling=\"auto\" style=\"box-sizing: inherit; position: absolute; top: 0px; left: 0px; width: 680px; height: 384.547px;\"></iframe></figure><h1 id=\"but-how\">But, how?</h1><p>In 2.6 or later versions of Redis the <code>redis-cli</code> utility supports a new mode called <strong><strong>pipe mode</strong></strong> that was designed in order to perform mass insertion.</p><h2 id=\"under-the-hood-of-pipe-mode\">Under the hood of pipe mode</h2><p>According to the official doc:</p><ul><li><em><em>redis-cli — pipe tries to send data as fast as possible to the server.</em></em></li><li><em><em>At the same time it reads data when available, trying to parse it.</em></em></li><li><em><em>Once there is no more data to read from stdin, it sends a special </em></em><strong><strong><em><em>ECHO</em></em></strong></strong><em><em> command with a random 20 bytes string: we are sure this is the latest command sent, and we are sure we can match the reply checking if we receive the same 20 bytes as a bulk reply.</em></em></li><li><em><em>Once this special final command is sent, the code receiving replies starts to match replies with these 20 bytes. When the matching reply is reached it can exit with success.</em></em></li></ul><h1 id=\"naice-what-s-next\">Naice, what’s next?</h1><p>Well, I tried populating Redis locally with <em><em>a million keys.</em></em></p><p>It worked like a charm, in just ~2 seconds. ?</p><figure class=\"kg-card kg-embed-card\"><iframe src=\"https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fgiphy.com%2Fembed%2Fj6ZQKMy3W3629lDJSX%2Ftwitter%2Fiframe&amp;display_name=Giphy&amp;url=https%3A%2F%2Fgiphy.com%2Fgifs%2Fhbo-avenue-5-avenue5-j6ZQKMy3W3629lDJSX&amp;image=https%3A%2F%2Fmedia.giphy.com%2Fmedia%2Fj6ZQKMy3W3629lDJSX%2Fgiphy.gif&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=giphy\" allowfullscreen=\"\" frameborder=\"0\" height=\"244\" width=\"435\" title=\"Hugh Laurie Charm GIF by HBO - Find &amp; Share on GIPHY\" class=\"s t u iu ai\" scrolling=\"auto\" style=\"box-sizing: inherit; position: absolute; top: 0px; left: 0px; width: 680px; height: 381.422px;\"></iframe></figure><h1 id=\"that-s-it-\">That’s it!</h1><p>I really hope that this post gave you some new insights.</p><p>Thanks for reading! ?</p><p><strong><strong>References</strong></strong></p><ol><li><a href=\"https://redis.io/topics/mass-insert\" rel=\"noopener\">Redis Mass Insertion</a></li><li><a href=\"https://redis.io/topics/protocol\" rel=\"noopener\">Redis Protocol</a></li><li><a href=\"https://kubernetes.io/docs/tasks/access-application-cluster/port-forward-access-application-cluster/\" rel=\"noopener\">Port Forwarding in Kubernetes to access applications</a></li></ol><figure class=\"kg-card kg-image-card\"><img src=\"https://miro.medium.com/max/60/1*Yigf1nGxRKjzV7vIC_YkYg.png?q=20\" class=\"kg-image\"></figure><p>Want our stories to land in your inbox? <a href=\"https://mailchi.mp/go-jek/gojek-tech-newsletter\" rel=\"noopener\">Sign up for our newsletter!</a></p>","url":"https://gojek-ghost.zysk.in/how-we-pushed-a-million-keys-to-redis-in-seconds/","canonical_url":null,"uuid":"399d0acb-04ee-4db6-8925-35c9dd3533e5","page":null,"codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5eafa30734df85001e15f489","reading_time":3},"tags":{"edges":[{"node":{"name":"Culture","slug":"culture"}},{"node":{"name":"Data","slug":"data"}},{"node":{"name":"Design","slug":"design"}},{"node":{"name":"News","slug":"news"}},{"node":{"name":"Stories","slug":"stories"}},{"node":{"name":"Tech","slug":"tech"}},{"node":{"name":"Maps","slug":"maps"}},{"node":{"name":"Ride Hailing","slug":"ride-hailing"}},{"node":{"name":"Software Engineering","slug":"software-engineering"}},{"node":{"name":"Startup","slug":"startup"}}]},"allGhostPost":{"edges":[{"node":{"id":"Ghost__Post__5ec94e8c7aa22c4066f83db2","title":"Tips for Building Smooth Live Tracking","slug":"tips-for-building-smooth-live-tracking","featured":false,"feature_image":"https://gojek-ghost.zysk.in/content/images/2020/05/LiveTracking-1.jpeg","excerpt":"How did we manage to build accurate tracking and smooth animations in our app? Here are your answers.","custom_excerpt":"How did we manage to build accurate tracking and smooth animations in our app? Here are your answers.","visibility":"public","created_at_pretty":"23 May, 2020","published_at_pretty":"22 May, 2020","updated_at_pretty":"23 May, 2020","created_at":"2020-05-23T21:55:48.000+05:30","published_at":"2020-05-22T09:00:00.000+05:30","updated_at":"2020-05-23T22:31:54.000+05:30","meta_title":null,"meta_description":null,"og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Gojek","slug":"gojek","bio":"Gojek is a Super App. It’s one app for ordering food, commuting, digital payments, shopping, hyper-local delivery, and two dozen services.","profile_image":"https://gojek-ghost.zysk.in/content/images/2020/05/logo-01-1.png","twitter":"@gojektech","facebook":"gojektech","website":"https://www.gojek.io"}],"primary_author":{"name":"Gojek","slug":"gojek","bio":"Gojek is a Super App. It’s one app for ordering food, commuting, digital payments, shopping, hyper-local delivery, and two dozen services.","profile_image":"https://gojek-ghost.zysk.in/content/images/2020/05/logo-01-1.png","twitter":"@gojektech","facebook":"gojektech","website":"https://www.gojek.io"},"primary_tag":{"name":"Tech","slug":"tech","description":"Learnings from technical challenges solved at Gojek, how-tos, and programming tips.","feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Tech","slug":"tech","description":"Learnings from technical challenges solved at Gojek, how-tos, and programming tips.","feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Ride Hailing","slug":"ride-hailing","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Startup","slug":"startup","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Maps","slug":"maps","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Software Engineering","slug":"software-engineering","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"By Divya Vikash\n\nIt’s a nice Monday morning and you just ordered a GoRide (one of Gojek’s\ntransport products) to go to your office. Voila!! You got a driver. That was\nfast. You can see your driver’s location on the map, and the estimated time they\nwould take to come to you.\n\nBut hang on… It seems like the map is a bit messed up.\n\nThe driver location on the map goes back and forth at unreal speed, and even\nflies over buildings. Starring in an action movie is not exactly how you want to\nstart your week. 😮\n\nWhile our driver-partners sure are superman in their own unique way, they\ncertainly can’t drive over buildings. This is clearly not how your driver is\nactually driving on the road. But then why is the map showing all this?\n\nWell, there are multiple factors that can lead to a bad experience like that.\nSome within our control, some not so much (as of now). We decided to go back to\nthe drawing board and figure out the issues that are in our control and fix them\nfor good. And that is how we built a world-class (arguably 😬) live-tracking\nexperience.\n\nBut what is live-tracking, you would ask?\n\nLive tracking is a complete map experience. It doesn’t involve anything other\nthan what you see on maps after you get a driver.\n\nSo, what do you see on maps?\n\n 1. Driver's location depicted by a green marker.\n 2. The routes.\n 3. The change in driver marker as the driver moves closer to your pickup/your\n    destination.\n 4. The change in route as the driver moves.\n\nAnd that’s it. That’s all live-tracking is.\n\n> But that sounds quite simple. Right? Use some routing APIs and plot the markers\nand routes.\nWell, yes, it sounded easy to us when we first heard about it too. The real\nexperience threw us a few curveballs. Let’s go through how we create a\nlive-tracking experience.\n\nInput\n\nLet’s look at the input data that we need to create a live-tracking animation:\n\nDriver Location and Routes\n\nOur driver apps have an in-built mechanism to upload driver location to our\nbackend at regular intervals. This is how we are able to find a driver close to\nyour location when you order one of our services. The primary input to\nlive-tracking is this driver location.\n\nIn our driver app, we get this location using Android’s FusedLocationProvider \nAPI which automatically uses the best location provider(GPS, Wifi, etc). The\ndriver location is ingested into our backend system via a continuous stream.\nRoutes are generated by our internal routing engine and provided to the customer\napp.\n\nInput Source\nAs you would have guessed, this data is provided via API calls initiated by the\nour Super App to the routing engine.\n\nMaking the API call just once won’t be sufficient. Right? The app needs to be\ninformed every time the driver’s location has changed. So, the customer app\npolls this API every few seconds to get this data.\n\nNow, we have a continuous stream of data flowing to our app which has all the\ninformation that we need to show the vehicle animation on the road.\n\nTerminology\nBefore moving forward, we should get acquainted with a few terminologies that we\nwould use quite frequently in this post.\n\n 1. Route: The entire list of latitude-longitudes between the driver location to\n    the pickup/destination location.\n 2. Segment: A segment is the smallest unit of a route. It is a straight line\n    from one position in the routes list to the very next position in the routes\n    list.\n\nA route of length n has n-1 segments. Confused? Yeah, let’s take an example.\n\nA Route looks like this:\n\n[{-62441198, 106.8032959},\n{-6.2440766, 106.80328}, \n{-6.2439977, 106.8033275},\n{-6.2434893, 106.8029214},\n{-6.2433926, 106.8030539},\n{-6.2436018, 106.803222}]\n\nThere are 5 Segments in this route.\n\nSegment 1: {-6.2441198, 106.8032959,-6.2440766, 106.80328}\nSegment 2: {-6.2440766, 106.80328,-6.2439977, 106.8033275}\nSegment 3: {-6.2439977, 106.8033275,-6.2434893, 106.8029214}\nSegment 4: {-6.2434893, 106.8029214,-6.2433926, 106.8030539}\nSegment 5: {-6.2433926, 106.8030539,-6.2436018, 106.8032224}\n\nThe initial setup\nWhen the user lands on the live tracking screen, the app immediately makes a\ncall to our internal API to get the driver location and route. Once we get this\ndata, we plot it on the map using the standard GoogleMap methods. \ngoogleMap.addMarker(), googleMap.addPolyline() etc.\n\nSometimes, we don’t have the routing information available immediately, so we\njust show the driver marker. We also store this data locally in an in-memory\ncache as we would need it later to do some comparisons.\n\nSo, the customer is able to see the markers and routes on the map now. So far so\ngood.\n\nThe subsequent updates\nAs I mentioned earlier, we need to change the position of driver marker and\nroute as the driver moves. The customer app makes a call to the same internal\nAPI every few seconds. After the first response, we don’t move any markers or\nroutes on the map until the next response succeeds.\n\nIn the next response, we again get the same data points i.e the route and driver\nlocation but with different values, of course, if the driver has moved. The next\nset of data that we get can have the following characteristics:\n\n 1. Route and driver location don’t change\n 2. Route changes\n 3. Route doesn’t change BUT driver location does\n\nLet’s discuss these cases one by one.\n\n1: Route and driver location don’t change\nIf nothing has changed, we don’t need to do anything. Probably our driver\npartner is stuck in traffic. 😞\n\n2: Route changes\nThis can happen either when:\n\n 1. The app was not showing any route to the user before i.e the first response\n    didn’t have the route.\n 2. The app was showing a route that is different from the newly received route.\n    This usually happens in cases where the driver starts following a different\n    route from the one they were following before. This can also happen due to\n    road closures or simply because our driver-partner initially followed a\n    wrong route by mistake 😅.\n\nIn either of these cases, we simply ignore the old driver marker and routes\nwhich were shown and plot the new marker and routes.\n\n3: Route doesn’t change BUT driver location does\nThe app was showing the same route to the user before i.e the old response had\nthe same route as the new response. This means that the driver is following the\noriginal route that we determined.\n\nIn this case, we need to animate the driver marker on the map from the old\nlocation to the new location along the same route. This is the most common\nscenario, which can again be broken down further into multiple scenarios (yeah,\nI’m all about breaking things down 🤐).\n\n3.1: Does the new location lie on the route?\nTo animate the driver marker from it’s current position to the new location, we\nfirst need to know whether the new location lies on the route or not.\n\nYeah, we can’t be sure that the driver location that we have received would\nalways lie on the route/road because of various GPS inaccuracy issues.\n\nWe iterate through every segment in the route to find the segment which has the\nnew location. For every segment, we use the Geometry/PolyUtil library to\ndetermine whether the driver location lies on that route.\n\nWe also specify a tolerance of a few meters to account for GPS inaccuracy. So,\nif the newly received location is within a radius of X meters near a segment,\nthis method will return true.\n\nAndroid\n\nboolean isLocationOnPath(LatLng point,List<LatLng> polyline,boolean geodesic,\ndouble tolerance)\n\niOS\n\nBOOL GMSGeometryIsLocationOnPathToleranc\n[https://developers.google.com/maps/documentation/ios-sdk/reference/group___geometry_utils#ga580ba381b9d4fbc0ff430cf69e06e66d]\ne(CLLocationCoordinate2D point,GMSPath\n[https://developers.google.com/maps/documentation/ios-sdk/reference/interface_g_m_s_path] \n* path,BOOL geodesic,CLLocationDistance tolerance)\n\nIf the location doesn’t lie on any of the segments in the route, we are sad and\nso, we don’t animate anything. But if it does, we go forward with the next step\nwhich is….\n\n3.2: Vehicle projection on route\nWhen we receive a new location, the start location is simply the position that\nthe driver marker is already at. No logic required there to calculate that.\n\nThe end location should simply be the new location that we received. Well, in an\nideal world, it should be but we live so far away from an ideal world 😞.\n\nAs we mentioned earlier, the raw driver location that we get from the driver app\nvia GPS/other providers mostly doesn’t lie on the road. So, we have to find a\nprojection of the driver location on the road/route.\n\nIf you have been reading carefully, you might wonder why we can’t just use the \nisLocationOnPath() method above 🤔.\n\nWell, if you had been reading more carefully, you might have noticed that this\nmethod returns a boolean explaining whether the location is on/near the route or\nnot 🤦‍♂. It doesn’t return the projected location. (Ohh..if someone from Maps\nUtils stumbled upon this by chance, please add that method, good sir).\n\nSo, we had to revise some maths. Yeah, folks, learn your maths well. You never\nknow when a situation like this might arise 🤷‍♂.\n\n“Find the projection of point (x,y) on the line y = mx + c”. Does that ring a\nbell? Drawing a perpendicular line towards the segment and calculating the\nlocation of where the line and route intersect can give us the projected\nlocation. Right?\n\nWell, the above approach works for 2-D systems but earth is not a 2-D space. We\nneed a way to project the spherical surface of the earth onto a rectangle 2-D\nspace. There are several ways to do that. All of them have certain drawbacks. We\nmight lose information like direction or the shape of landmasses/countries or\nthe area information.\n\nMercator Projection\n\nMercator projection is one of the available methods to project the spherical map\nof earth onto a rectangle to make usable maps. Most of the mapping tools used\nfor navigation use this projection.\n\nThe key feature of Mercator projection is that it retains the direction\ninformation. That means if point A is 30deg east from north of point B on the\nglobe, it will be in the same direction on its Mercator projection. Or say there\nis a turn of 90deg in some lane, it will be 90deg on Mercator projection as\nwell. That is the reason it works really well for navigation purposes.\n\nHow to use a Mercator projection?\n\n 1. Every point on the earth is projected on a cylinder exactly like point A\n    which has point A’ on the cylinder.\n 2. Once all the required points/routes are projected on this cylinder. It is\n    unrolled, and we obtain a rectangle like the one shown above.\n 3. All the planar geometry can be applied with a very little margin of error on\n    this 2D projected map.\n 4. After processing all the points/routes they can be converted back to\n    latitude and longitude on the globe.\n\nSo, now we have the projected driver location on the route which we will fondly\ncall snapped point going forward.\n\n3.3: End-to-End animation\nThe new driver location that we receive can be present in any segment. It may be\nthat it is in the same segment or it may be that it is on the next segment or on\nthe next one or it may be that it is on the last segment.\n\nBut for linear animation, we need a start point and an end point. The start\npoint is the current position of the driver marker. We already got the snapped\nendpoint in the earlier section. But we can’t just animate from start to end at\nonce as that would seem like the car is flying and ignoring U-turns, routes,\netc. So, how do we prevent it from flying?\n\nWhat do you do when you can’t fly to a place? You follow the road. Right? That’s\nwhat we have to do as well. Make the driver marker follow the route/road. We\nneed to animate along each segment in the route until we reach the segment which\nhas the driver position that we received.\n\nThere are again two cases here 😜:\n\n3.3.1: The new driver location is on the same segment\nIn this case, we can directly animate from the current position of driver marker\nto the driver location that we received since this is just a straight line\nanimation.\n\nA segment is always a straight line. We will discuss more on how to do the\nanimation b/w 2 points in a later section.\n\n3.3.2: The new driver location is on a different segment\nIn this case, we need to animate to that segment along the route. We have to\nanimate along each of the segments in between to reach the final segment.\n\nFor animation along the first segment, we set the endpoint of the animation to\nthe beginning of the next segment in the route. We animate to the end of the\nfirst segment.\n\nThe next segment may also not have the driver location that we received. After a\ndriver has traversed the first segment, we move the end location of the\nanimation to the end of the next segment, and so on and so forth till we reach\nthe last segment. Confusing, ya? Let’s see an example.\n\nSo much zig-zag (huh!!)The car icon(A) represents the location in the segment\nwhere the driver marker currently is. The red pin(X) represents the new snapped\nlocation received.\n\nIn the 1st animation, we move the driver marker from A to the end of the first\nsegment (B).\n\nIn the 2nd animation, the driver marker is moved through the entire length of\nthe 2nd segment.\n\nAnd so on and so forth till we reach the segment which has the newly received\nsnapped location (X).\n\nAnimation in a segment\nWe now know how the overall animation would look like. But we also need to\nconfigure how the smallest unit of the animation i.e animation in a segment\nshould happen.\n\nStart point and End point: For case #1 above, the animation in a segment will\nhappen just once. For case #2 above, this animation in a segment will happen\nmultiple times. Start and endpoints will be determined before beginning each of\nthe animations.\n\nBearing b/w these two points: Bearing can be calculated using another one of\nGeometry/Maps Utils method.\n\nSphericalUtil.computeHeading(startPosition, endPosition)\n\nDuration of animation: Calculating duration is a bit tricky. And the duration is\nthe most important thing in any animation. Sometimes the difference b/w a smooth\nand a choppy animation is caused by the duration. It was very important that we\ngot it right. So, let’s take a break and see how to calculate the duration.\n\nWhat is Duration?\nIt’s the amount of time for which the animation should happen. But you already\nknow that. Going back to middle school maths (yeah, that far), how do you\ncalculate time? Time is nothing but distance divided by speed. Correct?\nCalculating straight line distance b/w the two points we want to animate through\nis pretty easy.\n\nSphericalUtil.computeDistanceBetween(startLocation, endLocation)\n\nCool, cool. But what about speed? How should we calculate speed?\n\nSpeed calculation\nFusedLocationProvider API in the driver app does provide the speed of the\nvehicle but it’s highly unreliable. So, we have to employ some tricks to\ncalculate the speed.\n\nSpeed is distance divided by time. Distance again!! Seems like we are running in\ncircles 😵. Not exactly. Here the distance is not the straight line distance b/w\nthe two points that we have to animate through.\n\nThis is the total distance along the route from the segment that the old driver\nlocation is currently located at, to the segment where the new driver location\nis. Yeah, that statement is a bit confusing. So, let’s take an example.\n\nThe car icon(A) represents the location in the segment where the driver marker\ncurrently is. The red pin(X) represents the new snapped location received. To\ncalculate the distance, we do the obvious:\n\nTotal distance = d1 + d2 + d3 + d4\n\nNow, we have the distance. We need the time interval.\n\nThe FusedLocationProvider API in the driver app does provide us the timestamp at\nwhich a location was updated. And this information is passed to our backend and\nsubsequently to the customer app.\n\nWe calculate the time difference b/w the old driver location and the new driver\nlocation using their timestamps. Wait, how do we know the old driver location?\nAs we had mentioned earlier, we cache the last available driver location and\nroute in an in-memory cache.\n\nTotal route distance divided by time and now we have the speed for the entire\nduration. Linear distance divided by this speed and now we have the durationfor\na single animation in a segment. Cool, so let’s get back to the point where we\nbroke off 😅.\n\nUpdate the animation\nWith all the above information, we start the animation. But wait? Aren’t we\nmissing something? We did start an animation b/w two points but how will our\nanimator know how to animate?\n\nAnimation is just a bunch of frame updates that happen every fast. How do we\nupdate the marker position, the starting point of the route, the rotation in\neach and every frame of the animation? Well, the mobile/web framework allows us\nto do something every time the frame is updated.\n\nBut what is this something that we should do?\n\n1. Update marker’s position\nFor markers, we need to update their position. Once we have the position, we can\nsimply update the marker position using the marker.setPosition(). To find the\nposition during each frame of the animation, we need the percentage of animation\nthat has elapsed.\n\nWe can get the percentage from the Animation framework. Using this percentage\nand the start and end position, we calculate the intermediate position/s like\nthis:\n\nSphericalUtil.interpolate(startPosition, endPosition, fraction)\n\n2. Update Routes\nRoutes need to be aligned with the marker’s movement. So, we update the routes\nas well using the values above and updating the polyline points of that route\nusing the polyline.setPoints().\n\nAnd that’s a wrap. The result that we get is a very smooth, measured movement of\nthe vehicle along the road.\n\nThere are a few more tips/tricks that we employ to ensure that there are no\nabrupt changes in the animation.\n\nBut that’s for next time. 😃\n\nWhat’s next?\nWe still need to go a long way to meet the standards that we have set for\nourselves. Currently, this new experience is only rolled out to GoRide, GoCar,\nand GoBluebird. We are working on bringing the same experience to other services\nlike GoFood, GoSend, and GoShop. Stay tuned for more!\n\nWant stories like this one beamed straight to your inbox? Sign up for our\nnewsletter! [https://mailchi.mp/go-jek/gojek-tech-newsletter]\n\nThanks to Koushik Krishna, Abhay Sood, Anup Cowkur, Sooraj Rajmohan, and Kshitij\nChoudhary.","html":"<p><em><strong>By Divya Vikash</strong></em></p><p>It’s a nice Monday morning and you just ordered a GoRide (one of Gojek’s transport products) to go to your office. Voila!! You got a driver. That was fast. You can see your driver’s location on the map, and the estimated time they would take to come to you.</p><p><em><em>But hang on… It seems like the map is a bit messed up.</em></em></p><p>The driver location on the map goes back and forth at unreal speed, and even flies over buildings. Starring in an action movie is not exactly how you want to start your week. 😮</p><p>While our driver-partners sure are superman in their own unique way, they certainly can’t drive over buildings. This is clearly not how your driver is actually driving on the road. But then why is the map showing all this?</p><figure class=\"kg-card kg-image-card\"><img src=\"https://gojek-ghost.zysk.in/content/images/2020/05/LiveTracking2.gif\" class=\"kg-image\"></figure><p>Well, there are multiple factors that can lead to a bad experience like that. Some within our control, some not so much (as of now). We decided to go back to the drawing board and figure out the issues that are in our control and fix them for good. And that is how we built a world-class (arguably 😬) live-tracking experience.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://gojek-ghost.zysk.in/content/images/2020/05/image.png\" class=\"kg-image\"></figure><p>But what is live-tracking, you would ask?</p><p>Live tracking is a complete map experience. It doesn’t involve anything other than what you see on maps after you get a driver.</p><p>So, what do you see on maps?</p><ol><li>Driver's location depicted by a green marker.</li><li>The routes.</li><li>The change in driver marker as the driver moves closer to your pickup/your destination.</li><li>The change in route as the driver moves.</li></ol><p>And that’s it. That’s all live-tracking is.</p><blockquote><em><em>But that sounds quite simple. Right? Use some routing APIs and plot the markers and routes.</em></em></blockquote><p>Well, yes, it sounded easy to us when we first heard about it too. The real experience threw us a few curveballs. Let’s go through how we create a live-tracking experience.</p><p><strong>Input</strong></p><p>Let’s look at the input data that we need to create a live-tracking animation:</p><p><strong><strong>Driver Location and Routes</strong></strong></p><p>Our driver apps have an in-built mechanism to upload driver location to our backend at regular intervals. This is how we are able to find a driver close to your location when you order one of our services. The primary input to live-tracking is this driver location.</p><p>In our driver app, we get this location using Android’s <code>FusedLocationProvider</code> API which automatically uses the best location provider(GPS, Wifi, etc). The driver location is ingested into our backend system via a continuous stream. Routes are generated by our internal routing engine and provided to the customer app.</p><h3 id=\"input-source\">Input Source</h3><p>As you would have guessed, this data is provided via API calls initiated by the our Super App to the routing engine.</p><p>Making the API call just once won’t be sufficient. Right? The app needs to be informed every time the driver’s location has changed. So, the customer app polls this API every few seconds to get this data.</p><p>Now, we have a continuous stream of data flowing to our app which has all the information that we need to show the vehicle animation on the road.</p><h3 id=\"terminology\">Terminology</h3><p>Before moving forward, we should get acquainted with a few terminologies that we would use quite frequently in this post.</p><ol><li><strong><strong>Route</strong></strong>: The entire list of latitude-longitudes between the driver location to the pickup/destination location.</li><li><strong><strong>Segment</strong></strong>: A segment is the smallest unit of a route. It is a straight line from one position in the routes list to the very next position in the routes list.</li></ol><p>A route of length n has n-1 segments. Confused? Yeah, let’s take an example.</p><p>A <strong><strong>Route</strong></strong> looks like this:</p><p>[{-6<code>2441198, 106.8032959},<br>{-6.2440766, 106.80328}, <br>{-6.2439977, 106.8033275},<br>{-6.2434893, 106.8029214},<br>{-6.2433926, 106.8030539},<br>{-6.2436018, 106.803222}]</code></p><p>There are 5 <strong><strong>Segments</strong></strong> in this route.</p><p><code>Segment 1: {-6.2441198, 106.8032959,-6.2440766, 106.80328}</code><br><code>Segment 2: {-6.2440766, 106.80328,-6.2439977, 106.8033275}</code><br><code>Segment 3: {-6.2439977, 106.8033275,-6.2434893, 106.8029214}</code><br><code>Segment 4: {-6.2434893, 106.8029214,-6.2433926, 106.8030539}</code><br><code>Segment 5: {-6.2433926, 106.8030539,-6.2436018, 106.8032224}</code></p><figure class=\"kg-card kg-image-card\"><img src=\"https://gojek-ghost.zysk.in/content/images/2020/05/image-1.png\" class=\"kg-image\"></figure><h3 id=\"the-initial-setup\">The initial setup</h3><p>When the user lands on the live tracking screen, the app immediately makes a call to our internal API to get the driver location and route. Once we get this data, we plot it on the map using the standard GoogleMap methods. <code><em><em>googleMap.addMarker()</em></em></code><em><em>, </em></em><code><em><em>googleMap.addPolyline()</em></em></code> etc.</p><p>Sometimes, we don’t have the routing information available immediately, so we just show the driver marker. We also store this data locally in an in-memory cache as we would need it later to do some comparisons.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://miro.medium.com/max/436/1*k9IpgQ4ss-bhKHBY5ETUgg.gif\" class=\"kg-image\"></figure><p>So, the customer is able to see the markers and routes on the map now. So far so good.</p><h3 id=\"the-subsequent-updates\">The subsequent updates</h3><p>As I mentioned earlier, we need to change the position of driver marker and route as the driver moves. The customer app makes a call to the same internal API every few seconds. After the first response, we don’t move any markers or routes on the map until the next response succeeds.</p><p>In the next response, we again get the same data points i.e the route and driver location but with different values, of course, <strong><strong>if the driver has moved</strong></strong>. The next set of data that we get can have the following characteristics:</p><ol><li>Route and driver location don’t change</li><li>Route changes</li><li>Route doesn’t change BUT driver location does</li></ol><p>Let’s discuss these cases one by one.</p><h3 id=\"1-route-and-driver-location-don-t-change\">1: Route and driver location don’t change</h3><p>If nothing has changed, we don’t need to do anything. Probably our driver partner is stuck in traffic. 😞</p><h3 id=\"2-route-changes\">2: Route changes</h3><p>This can happen either when:</p><ol><li>The app was not showing any route to the user before i.e the first response didn’t have the route.</li><li>The app was showing a route that is different from the newly received route. This usually happens in cases where the driver starts following a different route from the one they were following before. This can also happen due to road closures or simply because our driver-partner initially followed a wrong route by mistake 😅.</li></ol><p>In either of these cases, we simply ignore the old driver marker and routes which were shown and plot the new marker and routes.</p><h3 id=\"3-route-doesn-t-change-but-driver-location-does\">3: Route doesn’t change BUT driver location does</h3><p>The app was showing the same route to the user before i.e the old response had the same route as the new response. This means that the driver is following the original route that we determined.</p><p>In this case, we need to animate the driver marker on the map from the old location to the new location along the same route. This is the most common scenario, which can again be broken down further into multiple scenarios (yeah, I’m all about breaking things down 🤐).</p><h3 id=\"3-1-does-the-new-location-lie-on-the-route\">3.1: Does the new location lie on the route?</h3><p>To animate the driver marker from it’s current position to the new location, we first need to know whether the new location lies on the route or not.</p><p>Yeah, we can’t be sure that the driver location that we have received would always lie on the route/road because of various GPS inaccuracy issues.</p><p>We iterate through every segment in the route to find the segment which has the new location. For every segment, we use the Geometry/PolyUtil library to determine whether the driver location lies on that route.</p><p>We also specify a tolerance of a few meters to account for GPS inaccuracy. So, if the newly received location is within a radius of <strong><strong>X meters</strong></strong> near a segment, this method will return true.</p><p><strong><strong>Android</strong></strong></p><p><code>boolean isLocationOnPath(LatLng point,List&lt;LatLng&gt; polyline,boolean geodesic, double tolerance)</code></p><p><strong><strong>iOS</strong></strong></p><p><code>BOOL <a href=\"https://developers.google.com/maps/documentation/ios-sdk/reference/group___geometry_utils#ga580ba381b9d4fbc0ff430cf69e06e66d\" rel=\"noopener\">GMSGeometryIsLocationOnPathToleranc</a>e(CLLocationCoordinate2D point,<a href=\"https://developers.google.com/maps/documentation/ios-sdk/reference/interface_g_m_s_path\" rel=\"noopener\">GMSPath</a> * path,BOOL geodesic,CLLocationDistance tolerance)</code></p><p>If the location doesn’t lie on any of the segments in the route, we are sad and so, we don’t animate anything. But if it does, we go forward with the next step which is….</p><h3 id=\"3-2-vehicle-projection-on-route\">3.2: Vehicle projection on route</h3><p>When we receive a new location, the start location is simply the position that the driver marker is already at. No logic required there to calculate that.</p><p>The end location should simply be the new location that we received. Well, in an ideal world, it <strong><strong>should be</strong></strong> but we live so far away from an ideal world 😞.</p><p>As we mentioned earlier, the raw driver location that we get from the driver app via GPS/other providers mostly doesn’t lie on the road. So, we have to find a projection of the driver location on the road/route.</p><p>If you have been reading carefully, you might wonder why we can’t just use the <em><em>isLocationOnPath()</em></em> method above 🤔.</p><p>Well, if you had been reading <em><em>more</em></em> carefully, you might have noticed that this method returns a boolean explaining whether the location is on/near the route or not 🤦‍♂. It doesn’t return the projected location. (Ohh..if someone from Maps Utils stumbled upon this by chance, please add that method, good sir).</p><p>So, we had to revise some maths. Yeah, folks, learn your maths well. You never know when a situation like this might arise 🤷‍♂.</p><p><em><em>“Find the projection of point (x,y) on the line y = mx + c”.</em></em> Does that ring a bell? Drawing a perpendicular line towards the segment and calculating the location of where the line and route intersect can give us the projected location. Right?</p><p>Well, the above approach works for 2-D systems but earth is not a 2-D space. We need a way to project the spherical surface of the earth onto a rectangle 2-D space. There are several ways to do that. All of them have certain drawbacks. We might lose information like direction or the shape of landmasses/countries or the area information.</p><p><strong><strong>Mercator Projection</strong></strong></p><p>Mercator projection is one of the available methods to project the spherical map of earth onto a rectangle to make usable maps. Most of the mapping tools used for navigation use this projection.</p><p>The key feature of Mercator projection is that it retains the direction information. That means if point A is 30deg east from north of point B on the globe, it will be in the same direction on its Mercator projection. Or say there is a turn of 90deg in some lane, it will be 90deg on Mercator projection as well. That is the reason it works really well for navigation purposes.</p><p><strong><strong>How to use a Mercator projection?</strong></strong></p><figure class=\"kg-card kg-image-card\"><img src=\"https://gojek-ghost.zysk.in/content/images/2020/05/image-4.png\" class=\"kg-image\"></figure><figure class=\"kg-card kg-image-card\"><img src=\"https://gojek-ghost.zysk.in/content/images/2020/05/image-5.png\" class=\"kg-image\"></figure><ol><li>Every point on the earth is projected on a cylinder exactly like point A which has point A’ on the cylinder.</li><li>Once all the required points/routes are projected on this cylinder. It is unrolled, and we obtain a rectangle like the one shown above.</li><li>All the planar geometry can be applied with a very little margin of error on this 2D projected map.</li><li>After processing all the points/routes they can be converted back to latitude and longitude on the globe.</li></ol><p>So, now we have the projected driver location on the route which we will fondly call <code>snapped point</code> going forward.</p><h3 id=\"3-3-end-to-end-animation\">3.3: End-to-End animation</h3><p>The new driver location that we receive can be present in <strong><strong>any</strong></strong> segment. It may be that it is in the same segment or it may be that it is on the next segment or on the next one or it may be that it is on the last segment.</p><p>But for linear animation, we need a start point and an end point. The start point is the current position of the driver marker. We already got the snapped endpoint in the earlier section. But we can’t just animate from start to end <strong><strong>at once</strong></strong> as that would seem like the car is flying and ignoring U-turns, routes, etc. So, how do we prevent it from flying?</p><p>What do you do when you can’t fly to a place? You follow the road. Right? That’s what we have to do as well. Make the driver marker follow the route/road. We need to animate along each segment in the route until we reach the segment which has the driver position that we received.</p><p>There are again two cases here 😜:</p><h3 id=\"3-3-1-the-new-driver-location-is-on-the-same-segment\">3.3.1: The new driver location is on the same segment</h3><p>In this case, we can directly animate from the current position of driver marker to the driver location that we received since this is just a straight line animation.</p><p>A segment is always a straight line. We will discuss more on how to do the animation b/w 2 points in a later section.</p><h3 id=\"3-3-2-the-new-driver-location-is-on-a-different-segment\">3.3.2: The new driver location is on a different segment</h3><p>In this case, we need to animate to that segment along the route. We have to animate along each of the segments in between to reach the final segment.</p><p>For animation along the first segment, we set the endpoint of the animation to the beginning of the next segment in the route. We animate to the end of the first segment.</p><p>The next segment may also not have the driver location that we received. After a driver has traversed the first segment, we move the end location of the animation to the end of the next segment, and so on and so forth till we reach the last segment. Confusing, ya? Let’s see an example.</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://gojek-ghost.zysk.in/content/images/2020/05/Screenshot-2020-05-23-at-10.06.55-PM.png\" class=\"kg-image\"><figcaption>So much zig-zag (huh!!)</figcaption></figure><p>The car icon(A) represents the location in the segment where the driver marker currently is. The red pin(X) represents the new snapped location received.</p><p>In the 1st animation, we move the driver marker from A to the end of the first segment (B).</p><p>In the 2nd animation, the driver marker is moved through the entire length of the 2nd segment.</p><p>And so on and so forth till we reach the segment which has the newly received snapped location (X).</p><h2 id=\"animation-in-a-segment\">Animation in a segment</h2><p>We now know how the overall animation would look like. But we also need to configure how the smallest unit of the animation i.e animation in a segment should happen.</p><p><strong><strong>Start point and End point</strong></strong>: For case #1 above, the animation in a segment will happen just once. For case #2 above, this animation in a segment will happen multiple times. Start and endpoints will be determined before beginning each of the animations.</p><p><strong><strong>Bearing b/w these two points</strong></strong>: Bearing can be calculated using another one of Geometry/Maps Utils method.</p><p><code>SphericalUtil.computeHeading(startPosition, endPosition)</code></p><p><strong><strong>Duration of animation: </strong></strong>Calculating duration is a bit tricky. And the duration is the most important thing in any animation. Sometimes the difference b/w a smooth and a choppy animation is caused by the duration. It was very important that we got it right. So, let’s take a break and see how to calculate the duration.</p><h2 id=\"what-is-duration\">What is Duration?</h2><p>It’s the amount of time for which the animation should happen. But you already know that. Going back to middle school maths (yeah, that far), how do you calculate time? Time is nothing but distance divided by speed. Correct? Calculating straight line distance b/w the two points we want to animate through is pretty easy.</p><p><code>SphericalUtil.computeDistanceBetween(startLocation, endLocation)</code></p><p>Cool, cool. But what about speed? How should we calculate speed?</p><h2 id=\"speed-calculation\">Speed calculation</h2><p><code>FusedLocationProvider</code> API in the driver app does provide the speed of the vehicle but it’s highly unreliable. So, we have to employ some tricks to calculate the speed.</p><p>Speed is distance divided by time. Distance again!! Seems like we are running in circles 😵. Not exactly. Here the distance is not the straight line distance b/w the two points that we have to animate through.</p><p>This is the total distance along the route <strong><strong>from</strong></strong> the segment that the old driver location is currently located at, <strong><strong>to</strong></strong> the segment where the new driver location is. Yeah, that statement is a bit confusing. So, let’s take an example.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://gojek-ghost.zysk.in/content/images/2020/05/image-8.png\" class=\"kg-image\"></figure><p>The car icon(A) represents the location in the segment where the driver marker currently is. The red pin(X) represents the new snapped location received. To calculate the distance, we do the obvious:</p><p><code>Total distance = d1 + d2 + d3 + d4</code></p><p>Now, we have the distance. We need the time interval.</p><p>The <code>FusedLocationProvider</code> API in the driver app does provide us the timestamp at which a location was updated. And this information is passed to our backend and subsequently to the customer app.</p><p>We calculate the time difference b/w the old driver location and the new driver location using their timestamps. Wait, how do we know the old driver location? As we had mentioned earlier, we cache the last available driver location and route in an in-memory cache.</p><p>Total route distance divided by time and now we have the speed for the entire duration. Linear distance divided by this speed and now we have the <strong><strong>duration</strong></strong>for a single animation in a segment. Cool, so let’s get back to the point where we broke off 😅.</p><h1 id=\"update-the-animation\">Update the animation</h1><p>With all the above information, we start the animation. But wait? Aren’t we missing something? We did start an animation b/w two points but how will our animator know <strong><strong>how</strong></strong> to animate?</p><p>Animation is just a bunch of frame updates that happen every fast. How do we update the marker position, the starting point of the route, the rotation in each and every frame of the animation? Well, the mobile/web framework allows us to do something every time the frame is updated.</p><p>But what is this something that we should do?</p><h2 id=\"1-update-marker-s-position\">1. Update marker’s position</h2><p>For markers, we need to update their position. Once we have the position, we can simply update the marker position using the <code>marker.setPosition()</code>. To find the position during each frame of the animation, we need the percentage of animation that has elapsed.</p><p>We can get the percentage from the Animation framework. Using this percentage and the start and end position, we calculate the intermediate position/s like this:</p><p><code>SphericalUtil.interpolate(startPosition, endPosition, fraction)</code></p><h2 id=\"2-update-routes\">2. Update Routes</h2><p>Routes need to be aligned with the marker’s movement. So, we update the routes as well using the values above and updating the polyline points of that route using the <code>polyline.setPoints()</code><em><em>.</em></em></p><p>And that’s a wrap. The result that we get is a very smooth, measured movement of the vehicle along the road.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://miro.medium.com/max/600/1*EtoKV1x7ufBgxOPdcsvnJg.gif\" class=\"kg-image\"></figure><p>There are a few more tips/tricks that we employ to ensure that there are no abrupt changes in the animation.</p><p>But that’s for next time. 😃</p><h3 id=\"what-s-next\">What’s next?</h3><p>We still need to go a long way to meet the standards that we have set for ourselves. Currently, this new experience is only rolled out to GoRide, GoCar, and GoBluebird. We are working on bringing the same experience to other services like GoFood, GoSend, and GoShop. Stay tuned for more!</p><figure class=\"kg-card kg-image-card\"><img src=\"https://gojek-ghost.zysk.in/content/images/2020/05/image-9.png\" class=\"kg-image\"></figure><p>Want stories like this one beamed straight to your inbox? <a href=\"https://mailchi.mp/go-jek/gojek-tech-newsletter\" rel=\"noopener\">Sign up for our newsletter!</a></p><p>Thanks to Koushik Krishna, Abhay Sood, Anup Cowkur, Sooraj Rajmohan, and Kshitij Choudhary.</p>","url":"https://gojek-ghost.zysk.in/tips-for-building-smooth-live-tracking/","canonical_url":null,"uuid":"90db33e9-3b67-4c66-a39f-7247172d3fa7","page":null,"codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5ec94e8c7aa22c4066f83db2","reading_time":13}},{"node":{"id":"Ghost__Post__5eb1066a5524cd001e7392a4","title":"Why We Swear by the RCA","slug":"why-we-swear-by-the-rca","featured":false,"feature_image":"https://res-3.cloudinary.com/hcq4cvthp/image/upload/q_auto/v1/ghost-blog-images/1_nOcToFzqvdWlHmOQ59v0sw.jpg","excerpt":"An account of how Gojek responds to production issues, and why the RCA is a critical part of the process.","custom_excerpt":"An account of how Gojek responds to production issues, and why the RCA is a critical part of the process.","visibility":"public","created_at_pretty":"05 May, 2020","published_at_pretty":"12 May, 2020","updated_at_pretty":"12 May, 2020","created_at":"2020-05-05T11:53:38.000+05:30","published_at":"2020-05-12T11:53:00.000+05:30","updated_at":"2020-05-12T11:53:20.000+05:30","meta_title":"Why We Swear by the RCA","meta_description":"An account of how Gojek responds to production issues, and why the RCA is a critical part of the process.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Gojek","slug":"gojek","bio":"Gojek is a Super App. It’s one app for ordering food, commuting, digital payments, shopping, hyper-local delivery, and two dozen services.","profile_image":"https://gojek-ghost.zysk.in/content/images/2020/05/logo-01-1.png","twitter":"@gojektech","facebook":"gojektech","website":"https://www.gojek.io"}],"primary_author":{"name":"Gojek","slug":"gojek","bio":"Gojek is a Super App. It’s one app for ordering food, commuting, digital payments, shopping, hyper-local delivery, and two dozen services.","profile_image":"https://gojek-ghost.zysk.in/content/images/2020/05/logo-01-1.png","twitter":"@gojektech","facebook":"gojektech","website":"https://www.gojek.io"},"primary_tag":{"name":"Stories","slug":"stories","description":"Deep dives into high-impact initiatives and products that helped Gojek create significant impact.","feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Stories","slug":"stories","description":"Deep dives into high-impact initiatives and products that helped Gojek create significant impact.","feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"When Gojek was still finding its feet, Fridays used to be a nightmare.\n\nJakarta, being the capital of the fourth most-populous country in the world, is\nhome to many people who work in the city and travel to their hometowns on\nweekends. Many of them rely on Gojek as their preferred first mile connectivity\noption — resulting in a traffic spike on our systems on Friday evening. In those\nearly days, this often triggered a system outage.\n\nEvery outage erodes the hard earned trust we build with our customers and driver\npartners.\n\nEnter the RCA\nWe knew we couldn’t fix the failures overnight, but we could learn from them.\nAfter all, so many of these mistakes were common and easily overlooked. So we\ndecided to embrace the ‘Root Cause Analysis’ (RCA). If something related to\nGojek’s Engineering division failed, the person(s) who attended the support call\nand had most context of what happened would prepare a document. This document\nwould contain a timeline, detail what went wrong, suggest corrective measures,\nand compile lessons learned.\n\nThis process ensured everyone across the organisation had visibility into what\nhappened. As a result, even unaffected teams cited in the RCA could analyse\ntheir systems to ensure the same problem would not happen to them. More\nimportantly, it provided a degree of accountability — and that’s important when\nyou have 20+ products.\n\nA post-mortem, and a prevention.\n\nThis post details what happens when a system failure happens at Gojek, and how\nit makes it way into an RCA.\n\n1. The What\nWhen something fails, it is important to understand the origin of the problem.\nEvery team in Gojek sets up alerts which monitor the state of their systems. If\na state change in the system causes a deviation from expected behaviour, an\nalerting service called pager duty automatically dials the phones of the people\nresponsible for that part of the system.\n\nHere’s an example:\n\nWhen a booking is created, we find a list of driver partners and send the order\ndetails to them, at which point they get a pop-up with trip details like\nestimated duration and approximate earnings. The idea is to give driver partners\nenough information to make the decision to accept the trip. But there was a\nproblem.\n\n2. The Why\nOne of the fields this prompt contains is a Booking ID, which is stored as an\ninteger (which, in technical speak, has a limit of 32 bits). Unfortunately for\nus, the ID generated exceeded this limit.\n\nWelcome to what we call Integer Overflow.\n\nAs a result of this, the driver app started crashing.\n\nHow bad can that be, you ask?\n\n3. The Fallout\nDrivers being unable to use the app means they can’t accept bookings. This means\ncustomers can’t book rides, send packages, get food, or use any service that\ndepends on our driver partners.\n\nAs a result, Gojek’s order numbers (or what we call ‘concurrence’, if you want\nto get all technical about it) plummeted. Pager duty is hit, and cell phones\nstart ringing off their proverbial hooks.\n\nWith driver partners stuck with malfunctioning apps, multiple Gojek services\nstart reporting errors. As customers try and figure out why the app is behaving\nthis way, engineers scramble to do the same.\n\n4. The Response\nWhen the phones ring, the team whose alerts have been triggered immediately get\nto work figuring out what happened. If they identify the problem quickly and\ndebug it, they notify other teams. The team then gets to work using information\nfrom the alerts and system dashboards to prepare an RCA.\n\nThis is, of course, the best case scenario.\n\nIf the concerned team cannot find a fix however, a war room is called.\n\nThe war room signifies a larger issue, and members of every available team drop\nwhat they’re doing and join the call. Sometimes, these are frantic Slack\ndiscussions and calls in the middle of the night. Other times, office boardrooms\nare blocked and everyone gathers to brainstorm collectively.\n\nDevs, Team Leads, Product Managers, all hands on deck.\n\nIn a war room scenario, whoever has most context on the situation takes charge\nand delegates tasks as required. This central person also plays a key role in\ndocumenting the happenings in the war room — how many people were present, which\nteams were represented, who was handling what, etc. All this information plays a\nkey role in the RCA. While this is going down, Driver and Customer Care centres\nare also notified, bracing for the inevitable flurry of complaints.\n\nThe fix may take the form of a few simple temporary hacks, or an hours long war\nroom — but in the end, there is always a fix.\n\nWords of appreciation from GoPay CEO Aldi Haryopratomo and Gojek CTO Ajey Gore\nAnd a sense of camaraderie ?\n\nOnce the dust settles, the investigation begins. The person who managed the war\nroom generally authors a document analysing what went wrong, using all the info\nfrom the alerts, dashboards, and firsthand accounts of the responders present.\nTypically every stakeholder in the organisation gets an email the next day with\ndetails of what went wrong — the RCA.\n\n5. The Learnings\n“Collaborate With Compassion”\n\nThese three words mean a lot at Gojek, and our RCAs reflect that. When you open\nan RCA mail, there is rarely even a mention of specific people, except to\nacknowledge those who responded to the distress call and played a role in\nfinding a fix. Call out the ones who made the effort, never the ones\nresponsible.\n\nMost RCAs instead dwell on relevant, actionable information. Information that\nwas being collected and monitored right from when the alert tripped:\n\nThe What: What was the problem?\n\nThe Why: Why did it happen?\n\nThe Fallout: Which services were affected, and for how long?\n\nThe Response: How was it fixed?\n\nThe Learnings: What can be done to avoid a repeat of this in future?\n\nThis simple process has helped us scale more safely and efficiently. It also\nallows for early identification of potential vulnerabilities in other systems.\nAs you may have noticed, there is no mention of who was responsible, no finger\npointing, no blame games. Collaborate with compassion.\n\nTo get a better sense of how we write RCAs at Gojek, read a sample RCA\n[https://docs.google.com/document/d/1r_PSsl7mBxbfAcibGTdFpnM5hm6ot82bF-_9VeV2J9w/edit?ts=5db7c330#heading=h.kreykp6cjau6]\n.\n\nIf you’d like to start a culture of RCAs as well, here’s our RCA template\n[https://docs.google.com/document/d/12Ims21IwFCNWi9MXcw2TVxPLB6YyWrIoTNaw3P-M_t4/edit]\n, courtesy GoPay CTO Ranjan Sakalley [https://twitter.com/rnjn], who also\noccasionally drops invaluable insights in the ‘Learnings’ section. ?\n\n\nRCAs have played an integral part in our journey to becoming a SuperApp.\nInvestigating, analysing, and documenting problems in production help us build\nbetter, more scalable systems, and tackle new problems in a mature manner\nwithout fear of retribution.\n\nThe days of weekly production issues are now a thing of the past. While we won’t\nbe so brash as to say we never have problems, embracing RCAs and a culture of\ncompassionate collaboration have helped us get to where we are today. ?\n\n\n--------------------------------------------------------------------------------\n\nWe’ll be writing about more interesting case studies on issues faced in\nproduction. Keep an eye on this blog, or subscribe to our newsletter\n[https://mailchi.mp/go-jek/gojek-tech-newsletter] for updates on our stories in\na neat little email.","html":"<p>When Gojek was still finding its feet, Fridays used to be a nightmare.</p><p>Jakarta, being the capital of the fourth most-populous country in the world, is home to many people who work in the city and travel to their hometowns on weekends. Many of them rely on Gojek as their preferred first mile connectivity option — resulting in a traffic spike on our systems on Friday evening. In those early days, this often triggered a system outage.</p><p><em><em>Every outage erodes the hard earned trust we build with our customers and driver partners.</em></em></p><h1 id=\"enter-the-rca\">Enter the RCA</h1><p>We knew we couldn’t fix the failures overnight, but we could learn from them. After all, so many of these mistakes were common and easily overlooked. So we decided to embrace the ‘Root Cause Analysis’ (RCA). If something related to Gojek’s Engineering division failed, the person(s) who attended the support call and had most context of what happened would prepare a document. This document would contain a timeline, detail what went wrong, suggest corrective measures, and compile lessons learned.</p><p>This process ensured everyone across the organisation had visibility into what happened. As a result, even unaffected teams cited in the RCA could analyse their systems to ensure the same problem would not happen to them. More importantly, it provided a degree of accountability — and that’s important when you have 20+ products.</p><p>A post-mortem, and a prevention.</p><p>This post details what happens when a system failure happens at Gojek, and how it makes it way into an RCA.</p><h2 id=\"1-the-what\">1. The What</h2><p>When something fails, it is important to understand the origin of the problem. Every team in Gojek sets up alerts which monitor the state of their systems. If a state change in the system causes a deviation from expected behaviour, an alerting service called <code>pager duty</code> automatically dials the phones of the people responsible for that part of the system.</p><p><strong><strong>Here’s an example:</strong></strong></p><p>When a booking is created, we find a list of driver partners and send the order details to them, at which point they get a pop-up with trip details like estimated duration and approximate earnings. The idea is to give driver partners enough information to make the decision to accept the trip. But there was a problem.</p><h2 id=\"2-the-why\">2. The Why</h2><p>One of the fields this prompt contains is a Booking ID, which is stored as an integer (which, in technical speak, has a limit of 32 bits). Unfortunately for us, the ID generated exceeded this limit.</p><p>Welcome to what we call Integer Overflow.</p><p>As a result of this, the driver app started crashing.</p><p><strong><strong><em><em>How bad can that be, you ask?</em></em></strong></strong></p><h2 id=\"3-the-fallout\">3. The Fallout</h2><p>Drivers being unable to use the app means they can’t accept bookings. This means customers can’t book rides, send packages, get food, or use any service that depends on our driver partners.</p><p>As a result, Gojek’s order numbers (or what we call ‘concurrence’, if you want to get all technical about it) plummeted. Pager duty is hit, and cell phones start ringing off their proverbial hooks.</p><p>With driver partners stuck with malfunctioning apps, multiple Gojek services start reporting errors. As customers try and figure out why the app is behaving this way, engineers scramble to do the same.</p><h2 id=\"4-the-response\">4. The Response</h2><p>When the phones ring, the team whose alerts have been triggered immediately get to work figuring out what happened. If they identify the problem quickly and debug it, they notify other teams. The team then gets to work using information from the alerts and system dashboards to prepare an RCA.</p><p><strong><strong>This is, of course, the best case scenario.</strong></strong></p><p>If the concerned team cannot find a fix however, a war room is called.</p><p>The war room signifies a larger issue, and members of every available team drop what they’re doing and join the call. Sometimes, these are frantic Slack discussions and calls in the middle of the night. Other times, office boardrooms are blocked and everyone gathers to brainstorm collectively.</p><p><em><em>Devs, Team Leads, Product Managers, all hands on deck.</em></em></p><p>In a war room scenario, whoever has most context on the situation takes charge and delegates tasks as required. This central person also plays a key role in documenting the happenings in the war room — <strong><strong>how many people were present, which teams were represented, who was handling what, etc.</strong></strong> <strong><strong>All this information plays a key role in the RCA.</strong></strong> While this is going down, Driver and Customer Care centres are also notified, bracing for the inevitable flurry of complaints.</p><p>The fix may take the form of a few simple temporary hacks, or an hours long war room — but in the end, there is always a fix.</p><figure class=\"kg-card kg-image-card kg-width-wide kg-card-hascaption\"><img src=\"https://miro.medium.com/max/1129/1*UFUYfO3Gw9tnKCiE1y40-Q.jpeg\" class=\"kg-image\"><figcaption>Words of appreciation from GoPay CEO Aldi Haryopratomo and Gojek CTO Ajey Gore</figcaption></figure><p><em><em>And a sense of camaraderie ?</em></em></p><p>Once the dust settles, the investigation begins. The person who managed the war room generally authors a document analysing what went wrong, using all the info from the alerts, dashboards, and firsthand accounts of the responders present. Typically every stakeholder in the organisation gets an email the next day with details of what went wrong — the RCA.</p><h2 id=\"5-the-learnings\">5. The Learnings</h2><p>“Collaborate With Compassion”</p><p>These three words mean a lot at Gojek, and our RCAs reflect that. When you open an RCA mail, there is rarely even a mention of specific people, except to acknowledge those who responded to the distress call and played a role in finding a fix. <strong><strong>Call out the ones who made the effort, never the ones responsible.</strong></strong></p><p>Most RCAs instead dwell on relevant, actionable information. Information that was being collected and monitored right from when the alert tripped:</p><p><em><em>The What: What was the problem?</em></em></p><p><em><em>The Why: Why did it happen?</em></em></p><p><em><em>The Fallout: Which services were affected, and for how long?</em></em></p><p><em><em>The Response: How was it fixed?</em></em></p><p><em><em>The Learnings: What can be done to avoid a repeat of this in future?</em></em></p><p>This simple process has helped us scale more safely and efficiently. It also allows for early identification of potential vulnerabilities in other systems. As you may have noticed, there is no mention of who was responsible, no finger pointing, no blame games. <em><em>Collaborate with compassion.</em></em></p><p>To get a better sense of how we write RCAs at Gojek, <a href=\"https://docs.google.com/document/d/1r_PSsl7mBxbfAcibGTdFpnM5hm6ot82bF-_9VeV2J9w/edit?ts=5db7c330#heading=h.kreykp6cjau6\" rel=\"noopener\"><strong><strong>read a sample RCA</strong></strong></a>.</p><p>If you’d like to start a culture of RCAs as well, <a href=\"https://docs.google.com/document/d/12Ims21IwFCNWi9MXcw2TVxPLB6YyWrIoTNaw3P-M_t4/edit\" rel=\"noopener\"><strong><strong>here’s our RCA template</strong></strong></a>, courtesy GoPay CTO <a href=\"https://twitter.com/rnjn\" rel=\"noopener\">Ranjan Sakalley</a>, who also occasionally drops invaluable insights in the ‘Learnings’ section. <strong><strong>?</strong></strong><br></p><figure class=\"kg-card kg-image-card\"><img src=\"https://miro.medium.com/max/480/1*2sosYEnk68lMaQTVjdZjWQ.jpeg\" class=\"kg-image\"></figure><p>RCAs have played an integral part in our journey to becoming a SuperApp. Investigating, analysing, and documenting problems in production help us build better, more scalable systems, and tackle new problems in a mature manner without fear of retribution.</p><p>The days of weekly production issues are now a thing of the past. While we won’t be so brash as to say we never have problems, embracing RCAs and a culture of compassionate collaboration have helped us get to where we are today. ?</p><hr><p>We’ll be writing about more interesting case studies on issues faced in production. Keep an eye on this blog, or <a href=\"https://mailchi.mp/go-jek/gojek-tech-newsletter\" rel=\"noopener\">subscribe to our newsletter</a> for updates on our stories in a neat little email.</p>","url":"https://gojek-ghost.zysk.in/why-we-swear-by-the-rca/","canonical_url":null,"uuid":"ef04187f-7199-434a-8647-6dcd386043cd","page":null,"codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5eb1066a5524cd001e7392a4","reading_time":5}},{"node":{"id":"Ghost__Post__5eafa30734df85001e15f489","title":"How We Pushed a Million Keys to Redis in Seconds","slug":"how-we-pushed-a-million-keys-to-redis-in-seconds","featured":false,"feature_image":"https://res-2.cloudinary.com/hcq4cvthp/image/upload/q_auto/v1/ghost-blog-images/1_gN5KGQcKSipjSlQqEppJMA.jpg","excerpt":"Dealing with a lot of keys? Redis’ Pipe Mode is your friend.\nHello there!\n\nIn this post, I’ll share my ideas on how we populated Redis (running in a\nKubernetes cluster)… in a matter of seconds.\n\nHere’s what can you expect from this post:\n\n1. How to connect to Redis server running in a Kubernetes cluster ?\n\n2. What is Port-forwarding ?\n\n3. How to use Redis mass insertion & push millions of keys in seconds ?\n\n4. How to generate Redis Protocol ?\n\n5. How to read /parse a CSV in Ruby ?\n\nWait, but why","custom_excerpt":null,"visibility":"public","created_at_pretty":"04 May, 2020","published_at_pretty":"04 May, 2020","updated_at_pretty":"12 May, 2020","created_at":"2020-05-04T10:37:19.000+05:30","published_at":"2020-05-04T10:45:13.000+05:30","updated_at":"2020-05-12T11:50:45.000+05:30","meta_title":"How We Pushed a Million Keys to Redis in Seconds","meta_description":"Dealing with a lot of keys? Redis’ Pipe Mode is your friend.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Gojek","slug":"gojek","bio":"Gojek is a Super App. It’s one app for ordering food, commuting, digital payments, shopping, hyper-local delivery, and two dozen services.","profile_image":"https://gojek-ghost.zysk.in/content/images/2020/05/logo-01-1.png","twitter":"@gojektech","facebook":"gojektech","website":"https://www.gojek.io"}],"primary_author":{"name":"Gojek","slug":"gojek","bio":"Gojek is a Super App. It’s one app for ordering food, commuting, digital payments, shopping, hyper-local delivery, and two dozen services.","profile_image":"https://gojek-ghost.zysk.in/content/images/2020/05/logo-01-1.png","twitter":"@gojektech","facebook":"gojektech","website":"https://www.gojek.io"},"primary_tag":{"name":"Tech","slug":"tech","description":"Learnings from technical challenges solved at Gojek, how-tos, and programming tips.","feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Tech","slug":"tech","description":"Learnings from technical challenges solved at Gojek, how-tos, and programming tips.","feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Dealing with a lot of keys? Redis’ Pipe Mode is your friend.\nHello there!\n\nIn this post, I’ll share my ideas on how we populated Redis (running in a\nKubernetes cluster)… in a matter of seconds.\n\nHere’s what can you expect from this post:\n\n1. How to connect to Redis server running in a Kubernetes cluster ?\n\n2. What is Port-forwarding ?\n\n3. How to use Redis mass insertion & push millions of keys in seconds ?\n\n4. How to generate Redis Protocol ?\n\n5. How to read /parse a CSV in Ruby ?\n\nWait, but why do I need to do this? ?\n\nAt Gojek, we use Redis in one of the services for caching drivers for faster\nlookups. Since we have deployed this service to new clusters, we needed to\npopulate Redis with ~81K keys.\n\nWhat we didn’t do (and should not be done)\nWell, this. ?\n\n$ redis-cli -h \"hostname\" -p 6379 set \"key\" \"value\"\n\nThis simple and easy way of storing a key through redis-cli\n[https://redis.io/topics/rediscli] is okay, but not for thousands or millions of\nkeys. You don’t want to end up waiting for hours unless you are Regina Phalange\n[https://en.wikipedia.org/wiki/Phoebe_Buffay#%22Regina_Phalange%22]! ?\n\nUsing a normal Redis client to perform mass insertion is not a good idea. The\nnaive approach of sending one command after the other is slow, because you have\nto pay for the round trip time for every command.\n\nLet’s do something different!\nWe will use Redis mass insertion, but before going to that, let’s talk a bit\nabout Redis Protocol [https://redis.io/topics/protocol].\n\nRedis clients communicate with the Redis server using a protocol called RESP \n(REdis Serialization Protocol).\n\nWith that said, let’s go write some code! I like toying around with Ruby\n[https://www.ruby-lang.org/en/], so this was my language of choice.\n\nredis_mass_insert.rbgen_redis_proto function will generate the protocol required for mass insertion.\n\n> 2.6.3 > puts gen_redis_proto(\"SET\",\"mykey\",\"Hello World!\").inspect\nRunning the above command in Ruby console, will give us the following protocol.\n\n\"*3\\r\\n$3\\r\\nSET\\r\\n$5\\r\\nmykey\\r\\n$12\\r\\nHello World!\\r\\n\"\n\nWell, this is how a command is represented and sent to the Redis Server through \nRedis Protocol [https://redis.io/topics/protocol].\n\n*<args><cr><lf>\n$<len><cr><lf>\n<arg0><cr><lf>\n<arg1><cr><lf>\n...\n<argN><cr><lf>\n\nWhere <cr> means \"\\r\" (or ASCII character 13) and <lf> means \"\\n\" (or ASCII\ncharacter 10).\n\nWe can now run this script, but here’s a catch. Our Redis server runs in a\nKubernetes cluster and we didn’t want to install Ruby and its gems inside a\ncluster. So now?\n\nEnter port-forwarding! ?\n$ kubectl -n \"namespace\" port-forward \"pod-name\" 7000:6379\n\nConnections made to local port 7000 are forwarded to port 6379 of the pod that\nis running the Redis server. With this connection in place we can use our local\nworkstation to debug the database that is running in the pod.\n\nFinally, we run our script to populate Redis ?\n\n> $ ruby redis_mass_insert.rb | redis-cli -p 7000 --pipe\n> All data transferred. Waiting for the last reply...\nLast reply received from server.\nerrors: 0, replies: 81003\nWe ran this script and it completed within a fraction of seconds!\n\nBut, how?\nIn 2.6 or later versions of Redis the redis-cli utility supports a new mode\ncalled pipe mode that was designed in order to perform mass insertion.\n\nUnder the hood of pipe mode\nAccording to the official doc:\n\n * redis-cli — pipe tries to send data as fast as possible to the server.\n * At the same time it reads data when available, trying to parse it.\n * Once there is no more data to read from stdin, it sends a special ECHO \n   command with a random 20 bytes string: we are sure this is the latest command\n   sent, and we are sure we can match the reply checking if we receive the same\n   20 bytes as a bulk reply.\n * Once this special final command is sent, the code receiving replies starts to\n   match replies with these 20 bytes. When the matching reply is reached it can\n   exit with success.\n\nNaice, what’s next?\nWell, I tried populating Redis locally with a million keys.\n\nIt worked like a charm, in just ~2 seconds. ?\n\nThat’s it!\nI really hope that this post gave you some new insights.\n\nThanks for reading! ?\n\nReferences\n\n 1. Redis Mass Insertion [https://redis.io/topics/mass-insert]\n 2. Redis Protocol [https://redis.io/topics/protocol]\n 3. Port Forwarding in Kubernetes to access applications\n    [https://kubernetes.io/docs/tasks/access-application-cluster/port-forward-access-application-cluster/]\n\nWant our stories to land in your inbox? Sign up for our newsletter!\n[https://mailchi.mp/go-jek/gojek-tech-newsletter]","html":"<h3 id=\"dealing-with-a-lot-of-keys-redis-pipe-mode-is-your-friend-\">Dealing with a lot of keys? Redis’ Pipe Mode is your friend.</h3><p>Hello there!</p><p>In this post, I’ll share my ideas on how we populated Redis (running in a Kubernetes cluster)… in a matter of seconds.</p><p>Here’s what can you expect from this post:</p><p><em><em>1. How to connect to Redis server running in a Kubernetes cluster ?</em></em></p><p><em><em>2. What is Port-forwarding ?</em></em></p><p><em><em>3. How to use Redis mass insertion &amp; push millions of keys in seconds ?</em></em></p><p><em><em>4. How to generate Redis Protocol ?</em></em></p><p><em><em>5. How to read /parse a CSV in Ruby ?</em></em></p><p>Wait, but why do I need to do this? ?</p><p>At Gojek, we use Redis in one of the services for caching drivers for faster lookups. Since we have deployed this service to new clusters, we needed to populate Redis with ~81K keys.</p><h2 id=\"what-we-didn-t-do-and-should-not-be-done-\">What we didn’t do (and should not be done)</h2><p>Well, this. ?</p><p><code>$ redis-cli -h \"hostname\" -p 6379 set \"key\" \"value\"</code></p><p>This simple and easy way of storing a key through <code><a href=\"https://redis.io/topics/rediscli\" rel=\"noopener\">redis-cli</a></code> is okay, but not for thousands or millions of keys. You don’t want to end up waiting for hours unless you are <a href=\"https://en.wikipedia.org/wiki/Phoebe_Buffay#%22Regina_Phalange%22\" rel=\"noopener\">Regina Phalange</a>! ?</p><figure class=\"kg-card kg-embed-card\"><iframe src=\"https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fgiphy.com%2Fembed%2F5xaOcLvROln5TmaaVOM%2Ftwitter%2Fiframe&amp;display_name=Giphy&amp;url=https%3A%2F%2Fgiphy.com%2Fgifs%2Fthecomebackhbo-comeback-the-val-cherish-5xaOcLvROln5TmaaVOM&amp;image=https%3A%2F%2Fmedia.giphy.com%2Fmedia%2F5xaOcLvROln5TmaaVOM%2Fgiphy.gif&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=giphy\" allowfullscreen=\"\" frameborder=\"0\" height=\"301\" width=\"435\" title=\"Lisa Kudrow Thank You GIF by The Comeback HBO - Find &amp; Share on GIPHY\" class=\"s t u iu ai\" scrolling=\"auto\" style=\"box-sizing: inherit; position: absolute; top: 0px; left: 0px; width: 680px; height: 470.516px;\"></iframe></figure><p>Using a normal Redis client to perform mass insertion is not a good idea. The naive approach of sending one command after the other is slow, because you have to pay for the round trip time for every command.</p><h1 id=\"let-s-do-something-different-\">Let’s do something different!</h1><p>We will use Redis mass insertion, but before going to that, let’s talk a bit about <a href=\"https://redis.io/topics/protocol\" rel=\"noopener\">Redis Protocol</a>.</p><p><em><em>Redis clients communicate with the Redis server using a protocol called <strong><strong>RESP</strong></strong> (REdis Serialization Protocol).</em></em></p><p>With that said, let’s go write some code! I like toying around with <a href=\"https://www.ruby-lang.org/en/\" rel=\"noopener\">Ruby</a>, so this was my language of choice.</p><figure class=\"kg-card kg-embed-card kg-card-hascaption\"><iframe src=\"https://blog.gojekengineering.com/media/59319951b0d29feee60832a68f811a18\" allowfullscreen=\"\" frameborder=\"0\" height=\"364\" width=\"680\" title=\"Ruby Script for Redis Mass Insertion\" class=\"s t u iu ai\" scrolling=\"auto\" style=\"box-sizing: inherit; position: absolute; top: 0px; left: 0px; width: 680px; height: 364px;\"></iframe><figcaption>redis_mass_insert.rb</figcaption></figure><p><code>gen_redis_proto</code> function will generate the protocol required for mass insertion.</p><blockquote>2.6.3 &gt; <strong><strong>puts gen_redis_proto(\"SET\",\"mykey\",\"Hello World!\").inspect</strong></strong></blockquote><p>Running the above command in Ruby console, will give us the following protocol.</p><p><code>\"*3\\r\\n$3\\r\\nSET\\r\\n$5\\r\\nmykey\\r\\n$12\\r\\nHello World!\\r\\n\"</code></p><p>Well, this is how a command is represented and sent to the Redis Server through <a href=\"https://redis.io/topics/protocol\" rel=\"noopener\">Redis Protocol</a>.</p><p><code>*&lt;args&gt;&lt;cr&gt;&lt;lf&gt;<br>$&lt;len&gt;&lt;cr&gt;&lt;lf&gt;<br>&lt;arg0&gt;&lt;cr&gt;&lt;lf&gt;<br>&lt;arg1&gt;&lt;cr&gt;&lt;lf&gt;<br>...<br>&lt;argN&gt;&lt;cr&gt;&lt;lf&gt;</code></p><p><em><em>Where <code>&lt;cr&gt;</code> means \"\\r\" (or ASCII character 13) and <code>&lt;lf&gt;</code> means \"\\n\" (or ASCII character 10).</em></em></p><p>We can now run this script, but here’s a catch. Our Redis server runs in a Kubernetes cluster and we didn’t want to install Ruby and its gems inside a cluster. So now?</p><h1 id=\"enter-port-forwarding-\">Enter port-forwarding! ?</h1><p><strong><strong><code>$ kubectl -n \"namespace\" port-forward \"pod-name\" 7000:6379</code></strong></strong></p><p>Connections made to local port 7000 are forwarded to port 6379 of the pod that is running the Redis server. With this connection in place we can use our local workstation to debug the database that is running in the pod.</p><p><em><em><em>Finally, we run our script to populate Redis ?</em></em></em></p><blockquote><strong><strong>$ ruby redis_mass_insert.rb | redis-cli -p 7000 --pipe</strong></strong></blockquote><blockquote>All data transferred. Waiting for the last reply...<br>Last reply received from server.<br>errors: 0, replies: 81003</blockquote><p>We ran this script and it completed within a fraction of seconds!</p><figure class=\"kg-card kg-embed-card\"><iframe src=\"https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fgiphy.com%2Fembed%2FjRARA4zqym98KmvkUy%2Ftwitter%2Fiframe&amp;display_name=Giphy&amp;url=https%3A%2F%2Fgiphy.com%2Fgifs%2FjRARA4zqym98KmvkUy&amp;image=https%3A%2F%2Fmedia.giphy.com%2Fmedia%2FjRARA4zqym98KmvkUy%2Fgiphy.gif&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=giphy\" allowfullscreen=\"\" frameborder=\"0\" height=\"246\" width=\"435\" title=\"Bingo GIF - Find &amp; Share on GIPHY\" class=\"s t u iu ai\" scrolling=\"auto\" style=\"box-sizing: inherit; position: absolute; top: 0px; left: 0px; width: 680px; height: 384.547px;\"></iframe></figure><h1 id=\"but-how\">But, how?</h1><p>In 2.6 or later versions of Redis the <code>redis-cli</code> utility supports a new mode called <strong><strong>pipe mode</strong></strong> that was designed in order to perform mass insertion.</p><h2 id=\"under-the-hood-of-pipe-mode\">Under the hood of pipe mode</h2><p>According to the official doc:</p><ul><li><em><em>redis-cli — pipe tries to send data as fast as possible to the server.</em></em></li><li><em><em>At the same time it reads data when available, trying to parse it.</em></em></li><li><em><em>Once there is no more data to read from stdin, it sends a special </em></em><strong><strong><em><em>ECHO</em></em></strong></strong><em><em> command with a random 20 bytes string: we are sure this is the latest command sent, and we are sure we can match the reply checking if we receive the same 20 bytes as a bulk reply.</em></em></li><li><em><em>Once this special final command is sent, the code receiving replies starts to match replies with these 20 bytes. When the matching reply is reached it can exit with success.</em></em></li></ul><h1 id=\"naice-what-s-next\">Naice, what’s next?</h1><p>Well, I tried populating Redis locally with <em><em>a million keys.</em></em></p><p>It worked like a charm, in just ~2 seconds. ?</p><figure class=\"kg-card kg-embed-card\"><iframe src=\"https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fgiphy.com%2Fembed%2Fj6ZQKMy3W3629lDJSX%2Ftwitter%2Fiframe&amp;display_name=Giphy&amp;url=https%3A%2F%2Fgiphy.com%2Fgifs%2Fhbo-avenue-5-avenue5-j6ZQKMy3W3629lDJSX&amp;image=https%3A%2F%2Fmedia.giphy.com%2Fmedia%2Fj6ZQKMy3W3629lDJSX%2Fgiphy.gif&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=giphy\" allowfullscreen=\"\" frameborder=\"0\" height=\"244\" width=\"435\" title=\"Hugh Laurie Charm GIF by HBO - Find &amp; Share on GIPHY\" class=\"s t u iu ai\" scrolling=\"auto\" style=\"box-sizing: inherit; position: absolute; top: 0px; left: 0px; width: 680px; height: 381.422px;\"></iframe></figure><h1 id=\"that-s-it-\">That’s it!</h1><p>I really hope that this post gave you some new insights.</p><p>Thanks for reading! ?</p><p><strong><strong>References</strong></strong></p><ol><li><a href=\"https://redis.io/topics/mass-insert\" rel=\"noopener\">Redis Mass Insertion</a></li><li><a href=\"https://redis.io/topics/protocol\" rel=\"noopener\">Redis Protocol</a></li><li><a href=\"https://kubernetes.io/docs/tasks/access-application-cluster/port-forward-access-application-cluster/\" rel=\"noopener\">Port Forwarding in Kubernetes to access applications</a></li></ol><figure class=\"kg-card kg-image-card\"><img src=\"https://miro.medium.com/max/60/1*Yigf1nGxRKjzV7vIC_YkYg.png?q=20\" class=\"kg-image\"></figure><p>Want our stories to land in your inbox? <a href=\"https://mailchi.mp/go-jek/gojek-tech-newsletter\" rel=\"noopener\">Sign up for our newsletter!</a></p>","url":"https://gojek-ghost.zysk.in/how-we-pushed-a-million-keys-to-redis-in-seconds/","canonical_url":null,"uuid":"399d0acb-04ee-4db6-8925-35c9dd3533e5","page":null,"codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5eafa30734df85001e15f489","reading_time":3}},{"node":{"id":"Ghost__Post__5eaf9f2234df85001e15f42d","title":"OK Google, Meet Gojek","slug":"ok-google-meet-gojekwe-added-gojeks-ride-hailing-and-food-ordering-functions-to-google-assistant-heres-what-we-learned-in-the-process","featured":true,"feature_image":"https://res-5.cloudinary.com/hcq4cvthp/image/upload/q_auto/v1/ghost-blog-images/1_QaQg1VnVWuhAebytXO-gKg.jpg","excerpt":"We added Gojek’s ride-hailing and food ordering functions to Google Assistant. Here’s what we learned in the process.","custom_excerpt":"We added Gojek’s ride-hailing and food ordering functions to Google Assistant. Here’s what we learned in the process.","visibility":"public","created_at_pretty":"04 May, 2020","published_at_pretty":"04 May, 2020","updated_at_pretty":"12 May, 2020","created_at":"2020-05-04T10:20:42.000+05:30","published_at":"2020-05-04T10:33:07.000+05:30","updated_at":"2020-05-12T11:46:27.000+05:30","meta_title":"Ok Google, Meet Gojek","meta_description":"We added Gojek’s ride-hailing and food ordering functions to Google Assistant. Here’s what we learned in the process.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Gojek","slug":"gojek","bio":"Gojek is a Super App. It’s one app for ordering food, commuting, digital payments, shopping, hyper-local delivery, and two dozen services.","profile_image":"https://gojek-ghost.zysk.in/content/images/2020/05/logo-01-1.png","twitter":"@gojektech","facebook":"gojektech","website":"https://www.gojek.io"}],"primary_author":{"name":"Gojek","slug":"gojek","bio":"Gojek is a Super App. It’s one app for ordering food, commuting, digital payments, shopping, hyper-local delivery, and two dozen services.","profile_image":"https://gojek-ghost.zysk.in/content/images/2020/05/logo-01-1.png","twitter":"@gojektech","facebook":"gojektech","website":"https://www.gojek.io"},"primary_tag":{"name":"Tech","slug":"tech","description":"Learnings from technical challenges solved at Gojek, how-tos, and programming tips.","feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Tech","slug":"tech","description":"Learnings from technical challenges solved at Gojek, how-tos, and programming tips.","feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"We added Gojek’s ride-hailing and food ordering functions to Google Assistant.\nHere’s what we learned in the process.\nBy Vikas Bajpayee and Lokesh Kalal\n\nOur aim behind building a Super App was to help our users get rid of the daily\nfrictions in their lives. But the journey doesn’t stop there. Even after\nbuilding all these convenient products, we still try and reduce frictions that\nmay be encountered even within our app — such as booking a ride or ordering\nfood.\n\nSo we thought, why don’t we integrate with Google Assistant, and let our users\ncommunicate with our products in a new way?\n\nIn this post, we explain how we integrated our food and transport products with\nthe Google Assistant.\n\nThe why\nWe’ve already addressed one part of the why — convenience. The other is user\nre-engagement. According to this survey\n[https://andrewchen.co/new-data-shows-why-losing-80-of-your-mobile-users-is-normal-and-that-the-best-apps-do-much-better/?utm_content=buffere4fa2&utm_medium=twitter.com&utm_source=social&utm_campaign=buffer] \nconducted by Silicon Valley researcher Andrew Chen 77% of users stop using an\napp three days after they install it. Within a month, that number goes up to\n90%. ?\n\nThe how\nTo help integrate Android apps with the Google Assistant, Google launched App\nActions:\n\nWhat are app actions?\nApp Actions are a new way to make your android app content available in places\nlike Google Search, Google Assistant etc. From a user’s perspective, App Actions\nbehave like shortcuts to parts of your Android app. When users invoke an App\nAction, the Assistant either launches a screen in the Android app that the user\nhas already installed or shows an embedded visual card (Android Slice) that\nusers can interact with.\n\nApp actions provide a faster way for users to access Android apps. It can be\nachieved in two ways:- either user can be directed to a specific\nactivity(screen) using a deep link or user may see relevant content on the\nAssistant itself called Slices.\n\nMore info on this can be found here: \nhttps://developers.google.com/assistant/app/overview\n\nWhat are Slices?\nSlices are super-powered app actions. They provide a way to interact with apps\nwithout moving away from Assistant by showing a small piece of UI within\nAssistant. Slices are UI templates that can display rich, dynamic, and\ninteractive content from the app in Google Assistant.\n\nSlices can help users perform tasks faster by enabling engagement outside of the\nfullscreen app experience.\n\nYou can build Slices as enhancements to App Actions.\n\nHere’s an example:\n\nWe choose to use slices to show food order status, as the order status will have\nlimited information (eg. Driver is on the way to Restaurant, with his location\non Map ) which can be easily shown in a small piece of UI segment.\n\nIn fact, this functionality was recently demoed on stage at a Google event in\nIndonesia. You can check it out below:\n\nApp Actions Demo at #Google4ID 2019How does it work?\nWhenever a user says or types something in Assistant, assistant parses the\nquery. If the query matches the built-in intent\n[https://developers.google.com/assistant/app/reference/built-in-intents] grammar\nthen Google Assistant extracts the query parameter in schema.org\n[https://schema.org/] and generates a deep link URL using the mapping we provide\nin an actions.xml file.\n\nGoogle then attaches those extracted parameters to the deep link URL and creates\na final deep link which allows a user to launch specific content or screens in\nthe app.\n\nLet’s dig a little deeper:\n\nGoogle applies Machine Learning and Artificial Intelligence (Natural Language\nProcessing) to understand all the sentences we type in Assistant.\n\nWhile users can type anything they want in Assistant and the system gets better\nat interpreting them over time, but there are some sentences for specific intent\nthat are fixed by Google. More info here\n[https://developers.google.com/assistant/app/reference/built-in-intents#create-taxi-reservation]\n.\n\nHow did we integrate our services with Assistant?\nThe core of integrating Gojek with Assistant involved creating actions on Google\nAssistant with actions.xml file.\n\nLet’s explore how to do this:\n\n1. Create actions.xml file in your XML folder. This contains all the actions\nwith built-in intents which define what actions our app can support in the\nAssistant. Each action contains built-in intents\n[https://developers.google.com/assistant/app/reference/built-in-intents#create-taxi-reservation] \nsupported by Google as a <intent-name> tag.\n\n2. Define a fulfilment mode for each app action — which can be deep links or\nslices. You have to pass a fulfilment mode in each action. This is compulsory.\n\n3. Pass the URL template which will allow a user to launch your app — this can\nbe the deep link to your app or URL to Slice provider.\n\n4. Define entity-set — the Gojek app is available in multiple locales, so to\nprovide locale for all the regions, we added the entity-set, which allows\nAssistant to understand more than one version of category. ex:- taxi can be\npronounced as taksi in Bahasa.\n\nSo, If you want locale for your specific parameter in deep-link URL, you can\nsimply attach an entity-set with that parameter, see how you can achieve this in\nbelow example\n\n<parameter name=”taxiReservation.category”><entity-set-reference\nentitySetId=”TransportCategoryEntitySet” /></parameter>\n\n5. Add a reference to actions.xml file using the <meta> tag in your app’s\nmanifest.xml file inside the application tag.\n\nIn order to integrate Slices:\n\n 1. Implement an Android Slice by following the steps described in the Slices\n    Getting Started guide\n    [https://developer.android.com/guide/slices/getting-started].\n 2. In the actions.xml file, in the <fulfillment> element, specify \n    fulfillmentMode=“actions.fulfillment.SLICE” to indicate that a user intent\n    can be fulfilled using a Slice in your app.\n\nA few quick notes on what we learnt\n 1. Testing this feature is pretty hard and things become weird when you have\n    multiple build types of your app. For testing, you need a build type on the\n    Play Store, (which means the package name of the testing build should match\n    the package name of the published app). You can use a plugin (developed by\n    Google) called App Actions Test Tool\n    [https://developers.google.com/assistant/app/test-tool] for testing this\n    feature.\n\n> Please make sure you are following points while testing with App Actions Test\nTool:\na) Log in to Android Studio and Google Assistant with the account which has\naccess to your published app on Play console.\nb) ApplicationId of the app should be the same as your published app.\nc) Your Gradle should be built successfully.\nd) Use App Action Tool to create and update preview and test the app actions and\nslice.\n2. If your app is used in different locales, you can create locales using \nentity-set\n[https://developers.google.com/assistant/app/action-schema#entity-set-reference] \nin the actions.xml file.\n\n3. In order to give early builds to QA or other users (if you have multiple\nbuild types in your app), you can create an internal test track on Play console\nand add relevant people to it. This allows you to share the build to production\nfor only some listed users.\n\n(See this\n[https://support.google.com/googleplay/android-developer/answer/3131213?hl=en] \nfor how you can create an internal test track for your app.)\n\n4. Actions.xml shouldn’t be obfuscated in release apk — it means if you are\nusing any obfuscated tools like proguard then actions.xml shouldn’t be\nobfuscated there.\n\n5. Slices can be requested before the onCreate of your application is completed.\nYou can run into issues if you are using something which is initialised in \nonCreate while creating slices.\n\n6. Don't refresh slices from onBindSlice() method, it will end up in an infinite\nloop where Google Assistant will call onBindSlice() infinitely.\n\nThat’s all from us folks. Hope this post gave you a better understanding of how\nApp Actions and Slices work with Google Assistant. Working on this feature was\nan amazing experience for us. If you use the Gojek app, make sure to give them a\ntry and let us know what you think. ?\n\n\n--------------------------------------------------------------------------------\n\nLiked what you read? Sign up for our newsletter\n[https://mailchi.mp/go-jek/gojek-tech-newsletter] and we’ll send you updates\nfrom the blog straight to your inbox! ?","html":"<h3 id=\"we-added-gojek-s-ride-hailing-and-food-ordering-functions-to-google-assistant-here-s-what-we-learned-in-the-process-\">We added Gojek’s ride-hailing and food ordering functions to Google Assistant. Here’s what we learned in the process.</h3><p><strong><strong><em>By Vikas Bajpayee and Lokesh Kalal</em></strong></strong></p><p>Our aim behind building a Super App was to help our users get rid of the daily frictions in their lives. But the journey doesn’t stop there. Even after building all these convenient products, we still try and reduce frictions that may be encountered even within our app — such as booking a ride or ordering food.</p><p>So we thought, why don’t we integrate with Google Assistant, and let our users communicate with our products in a new way?</p><p>In this post, we explain how we integrated our food and transport products with the Google Assistant.</p><h1 id=\"the-why\">The why</h1><p>We’ve already addressed one part of the <em><em>why — </em></em>convenience. The other is user re-engagement. According to <a href=\"https://andrewchen.co/new-data-shows-why-losing-80-of-your-mobile-users-is-normal-and-that-the-best-apps-do-much-better/?utm_content=buffere4fa2&amp;utm_medium=twitter.com&amp;utm_source=social&amp;utm_campaign=buffer\" rel=\"noopener\">this survey</a> conducted by Silicon Valley researcher Andrew Chen 77% of users stop using an app three days after they install it. Within a month, that number goes up to 90%. ?</p><h1 id=\"the-how\">The how</h1><p>To help integrate Android apps with the Google Assistant, Google launched App Actions:</p><h2 id=\"what-are-app-actions\">What are app actions?</h2><p>App Actions are a new way to make your android app content available in places like Google Search, Google Assistant etc. From a user’s perspective, App Actions behave like shortcuts to parts of your Android app. When users invoke an App Action, the Assistant either launches a screen in the Android app that the user has already installed or shows an embedded visual card (Android Slice) that users can interact with.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://miro.medium.com/max/260/1*w4jk-CTME9amkb5dsIQDzw.gif\" class=\"kg-image\"></figure><p>App actions provide a faster way for users to access Android apps. It can be achieved in two ways:- either user can be directed to a specific activity(screen) using a deep link or user may see relevant content on the Assistant itself called Slices.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://miro.medium.com/max/260/1*KPBLtVMjiHBOPEJ53E9F8A.gif\" class=\"kg-image\"></figure><p>More info on this can be found here: <a href=\"https://developers.google.com/assistant/app/overview\" rel=\"noopener\">https://developers.google.com/assistant/app/overview</a></p><h2 id=\"what-are-slices\"><strong>What are Slices?</strong></h2><p>Slices are super-powered app actions. They provide a way to interact with apps without moving away from Assistant by showing a small piece of UI within Assistant. Slices are UI templates that can display rich, dynamic, and interactive content from the app in Google Assistant.</p><p><em><em>Slices can help users perform tasks faster by enabling engagement outside of the fullscreen app experience.</em></em></p><p>You can build Slices as enhancements to App Actions.</p><p>Here’s an example:</p><figure class=\"kg-card kg-image-card\"><img src=\"https://miro.medium.com/max/1080/1*EFF30b3185UtwKYjx0VP1A.jpeg\" class=\"kg-image\"></figure><p>We choose to use slices to show food order status, as the order status will have limited information (eg. Driver is on the way to Restaurant, with his location on Map ) which can be easily shown in a small piece of UI segment.</p><p>In fact, this functionality was recently demoed on stage at a Google event in Indonesia. You can check it out below:</p><figure class=\"kg-card kg-embed-card kg-card-hascaption\"><iframe src=\"https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2F0u20Iu4m2Co%3Fstart%3D5805%26feature%3Doembed%26start%3D5805&amp;url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3D0u20Iu4m2Co&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2F0u20Iu4m2Co%2Fhqdefault.jpg&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=youtube\" allowfullscreen=\"\" frameborder=\"0\" height=\"480\" width=\"854\" title=\"#Google4ID 2019\" class=\"s t u iu ai\" scrolling=\"auto\" style=\"box-sizing: inherit; position: absolute; top: 0px; left: 0px; width: 680px; height: 382.188px;\"></iframe><figcaption>App Actions Demo at #Google4ID 2019</figcaption></figure><h1 id=\"how-does-it-work\"><strong>How does it work?</strong></h1><p>Whenever a user says or types something in Assistant, assistant parses the query. If the query matches the<a href=\"https://developers.google.com/assistant/app/reference/built-in-intents\" rel=\"noopener\"> built-in intent</a> grammar then Google Assistant extracts the query parameter in<a href=\"https://schema.org/\" rel=\"noopener\"> schema.org</a> and generates a deep link URL using the mapping we provide in an actions.xml file.</p><p>Google then attaches those extracted parameters to the deep link URL and creates a final deep link which allows a user to launch specific content or screens in the app.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://miro.medium.com/max/1490/0*jUlpzwbXbFIgGy7s\" class=\"kg-image\"></figure><p>Let’s dig a little deeper:</p><p>Google applies Machine Learning and Artificial Intelligence (Natural Language Processing) to understand all the sentences we type in Assistant.</p><p>While users can type anything they want in Assistant and the system gets better at interpreting them over time, but there are some sentences for specific intent that are fixed by Google. More info <a href=\"https://developers.google.com/assistant/app/reference/built-in-intents#create-taxi-reservation\" rel=\"noopener\">here</a>.</p><h1 id=\"how-did-we-integrate-our-services-with-assistant\"><strong>How did we integrate our services with Assistant?</strong></h1><p>The core of integrating Gojek with Assistant involved creating actions on Google Assistant with actions.xml file.</p><p>Let’s explore how to do this:</p><p>1. Create <strong><strong>actions.xml</strong></strong> file in your XML folder. This contains all the actions with built-in intents which define what actions our app can support in the Assistant. Each action contains<a href=\"https://developers.google.com/assistant/app/reference/built-in-intents#create-taxi-reservation\" rel=\"noopener\"> built-in intents</a> supported by Google as a &lt;intent-name&gt; tag.</p><p>2. Define a fulfilment mode for each app action — which can be deep links or slices. You have to pass a fulfilment mode in each action. This is compulsory.</p><p>3. Pass the URL template which will allow a user to launch your app — this can be the deep link to your app or URL to Slice provider.</p><p>4. Define entity-set — the Gojek app is available in multiple locales, so to provide locale for all the regions, we added the entity-set, which allows Assistant to understand more than one version of category. ex:- taxi can be pronounced as taksi in Bahasa.</p><p>So, If you want locale for your specific parameter in deep-link URL, you can simply attach an entity-set with that parameter, see how you can achieve this in below example</p><p><em>&lt;parameter name=”taxiReservation.category”&gt;&lt;entity-set-reference entitySetId=”TransportCategoryEntitySet” /&gt;&lt;/parameter&gt;</em></p><p>5. Add a reference to <strong><strong>actions.xml</strong></strong> file using the &lt;meta&gt; tag in your app’s manifest.xml file inside the application tag.</p><p><strong><strong>In order to integrate Slices:</strong></strong></p><ol><li>Implement an Android Slice by following the steps described in the <a href=\"https://developer.android.com/guide/slices/getting-started\" rel=\"noopener\">Slices Getting Started guide</a>.</li><li>In the actions.xml file, in the <code>&lt;fulfillment&gt;</code> element, specify <code>fulfillmentMode=“actions.fulfillment.SLICE”</code> to indicate that a user intent can be fulfilled using a Slice in your app.</li></ol><h1 id=\"a-few-quick-notes-on-what-we-learnt\"><strong>A few quick notes on what we learnt</strong></h1><ol><li>Testing this feature is pretty hard and things become weird when you have multiple build types of your app. For testing, you need a build type on the Play Store, (which means the package name of the testing build should match the package name of the published app). You can use a plugin (developed by Google) called<a href=\"https://developers.google.com/assistant/app/test-tool\" rel=\"noopener\"> <strong><strong>App Actions Test Tool</strong></strong></a> for testing this feature.</li></ol><blockquote><em><em>Please make sure you are following points while testing with App Actions Test Tool:</em></em><br><em><em>a) Log in to Android Studio and Google Assistant with the account which has access to your published app on Play console.</em></em><br><em><em>b) <code>ApplicationId</code> of the app should be the same as your published app.</em></em><br><em><em>c) Your Gradle should be built successfully.</em></em><br><em><em>d) Use App Action Tool to create and update preview and test the app actions and slice.</em></em></blockquote><p>2. If your app is used in different locales, you can create locales using <a href=\"https://developers.google.com/assistant/app/action-schema#entity-set-reference\" rel=\"noopener\">entity-set</a> in the actions.xml file.</p><p>3. In order to give early builds to QA or other users (if you have multiple build types in your app), you can create an internal test track on Play console and add relevant people to it. This allows you to share the build to production for only some listed users.</p><p>(See <a href=\"https://support.google.com/googleplay/android-developer/answer/3131213?hl=en\" rel=\"noopener\">this</a> for how you can create an internal test track for your app.)</p><p>4. Actions.xml shouldn’t be <strong><strong>obfuscated</strong></strong> in release apk — it means if you are using any obfuscated tools like proguard then actions.xml shouldn’t be obfuscated there.</p><p>5. Slices can be requested before the <code>onCreate</code> of your application is completed. You can run into issues if you are using something which is initialised in <code>onCreate</code> while creating slices.</p><p>6. Don't refresh slices from <code>onBindSlice()</code> method, it will end up in an infinite loop where Google Assistant will call <code>onBindSlice()</code> infinitely.</p><p>That’s all from us folks. Hope this post gave you a better understanding of how App Actions and Slices work with Google Assistant. Working on this feature was an amazing experience for us. If you use the Gojek app, make sure to give them a try and let us know what you think. ?</p><hr><p>Liked what you read? <a href=\"https://mailchi.mp/go-jek/gojek-tech-newsletter\" rel=\"noopener\">Sign up for our newsletter</a> and we’ll send you updates from the blog straight to your inbox! ?</p>","url":"https://gojek-ghost.zysk.in/ok-google-meet-gojekwe-added-gojeks-ride-hailing-and-food-ordering-functions-to-google-assistant-heres-what-we-learned-in-the-process/","canonical_url":null,"uuid":"a980d332-756f-4f47-a97f-921a11196ed7","page":null,"codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5eaf9f2234df85001e15f42d","reading_time":6}}]},"otherPost":{"edges":[{"node":{"id":"Ghost__Post__5eb1066a5524cd001e7392a4","title":"Why We Swear by the RCA","slug":"why-we-swear-by-the-rca","featured":false,"feature_image":"https://res-3.cloudinary.com/hcq4cvthp/image/upload/q_auto/v1/ghost-blog-images/1_nOcToFzqvdWlHmOQ59v0sw.jpg","excerpt":"An account of how Gojek responds to production issues, and why the RCA is a critical part of the process.","custom_excerpt":"An account of how Gojek responds to production issues, and why the RCA is a critical part of the process.","visibility":"public","created_at_pretty":"05 May, 2020","published_at_pretty":"12 May, 2020","updated_at_pretty":"12 May, 2020","created_at":"2020-05-05T11:53:38.000+05:30","published_at":"2020-05-12T11:53:00.000+05:30","updated_at":"2020-05-12T11:53:20.000+05:30","meta_title":"Why We Swear by the RCA","meta_description":"An account of how Gojek responds to production issues, and why the RCA is a critical part of the process.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Gojek","slug":"gojek","bio":"Gojek is a Super App. It’s one app for ordering food, commuting, digital payments, shopping, hyper-local delivery, and two dozen services.","profile_image":"https://gojek-ghost.zysk.in/content/images/2020/05/logo-01-1.png","twitter":"@gojektech","facebook":"gojektech","website":"https://www.gojek.io"}],"primary_author":{"name":"Gojek","slug":"gojek","bio":"Gojek is a Super App. It’s one app for ordering food, commuting, digital payments, shopping, hyper-local delivery, and two dozen services.","profile_image":"https://gojek-ghost.zysk.in/content/images/2020/05/logo-01-1.png","twitter":"@gojektech","facebook":"gojektech","website":"https://www.gojek.io"},"primary_tag":{"name":"Stories","slug":"stories","description":"Deep dives into high-impact initiatives and products that helped Gojek create significant impact.","feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Stories","slug":"stories","description":"Deep dives into high-impact initiatives and products that helped Gojek create significant impact.","feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"When Gojek was still finding its feet, Fridays used to be a nightmare.\n\nJakarta, being the capital of the fourth most-populous country in the world, is\nhome to many people who work in the city and travel to their hometowns on\nweekends. Many of them rely on Gojek as their preferred first mile connectivity\noption — resulting in a traffic spike on our systems on Friday evening. In those\nearly days, this often triggered a system outage.\n\nEvery outage erodes the hard earned trust we build with our customers and driver\npartners.\n\nEnter the RCA\nWe knew we couldn’t fix the failures overnight, but we could learn from them.\nAfter all, so many of these mistakes were common and easily overlooked. So we\ndecided to embrace the ‘Root Cause Analysis’ (RCA). If something related to\nGojek’s Engineering division failed, the person(s) who attended the support call\nand had most context of what happened would prepare a document. This document\nwould contain a timeline, detail what went wrong, suggest corrective measures,\nand compile lessons learned.\n\nThis process ensured everyone across the organisation had visibility into what\nhappened. As a result, even unaffected teams cited in the RCA could analyse\ntheir systems to ensure the same problem would not happen to them. More\nimportantly, it provided a degree of accountability — and that’s important when\nyou have 20+ products.\n\nA post-mortem, and a prevention.\n\nThis post details what happens when a system failure happens at Gojek, and how\nit makes it way into an RCA.\n\n1. The What\nWhen something fails, it is important to understand the origin of the problem.\nEvery team in Gojek sets up alerts which monitor the state of their systems. If\na state change in the system causes a deviation from expected behaviour, an\nalerting service called pager duty automatically dials the phones of the people\nresponsible for that part of the system.\n\nHere’s an example:\n\nWhen a booking is created, we find a list of driver partners and send the order\ndetails to them, at which point they get a pop-up with trip details like\nestimated duration and approximate earnings. The idea is to give driver partners\nenough information to make the decision to accept the trip. But there was a\nproblem.\n\n2. The Why\nOne of the fields this prompt contains is a Booking ID, which is stored as an\ninteger (which, in technical speak, has a limit of 32 bits). Unfortunately for\nus, the ID generated exceeded this limit.\n\nWelcome to what we call Integer Overflow.\n\nAs a result of this, the driver app started crashing.\n\nHow bad can that be, you ask?\n\n3. The Fallout\nDrivers being unable to use the app means they can’t accept bookings. This means\ncustomers can’t book rides, send packages, get food, or use any service that\ndepends on our driver partners.\n\nAs a result, Gojek’s order numbers (or what we call ‘concurrence’, if you want\nto get all technical about it) plummeted. Pager duty is hit, and cell phones\nstart ringing off their proverbial hooks.\n\nWith driver partners stuck with malfunctioning apps, multiple Gojek services\nstart reporting errors. As customers try and figure out why the app is behaving\nthis way, engineers scramble to do the same.\n\n4. The Response\nWhen the phones ring, the team whose alerts have been triggered immediately get\nto work figuring out what happened. If they identify the problem quickly and\ndebug it, they notify other teams. The team then gets to work using information\nfrom the alerts and system dashboards to prepare an RCA.\n\nThis is, of course, the best case scenario.\n\nIf the concerned team cannot find a fix however, a war room is called.\n\nThe war room signifies a larger issue, and members of every available team drop\nwhat they’re doing and join the call. Sometimes, these are frantic Slack\ndiscussions and calls in the middle of the night. Other times, office boardrooms\nare blocked and everyone gathers to brainstorm collectively.\n\nDevs, Team Leads, Product Managers, all hands on deck.\n\nIn a war room scenario, whoever has most context on the situation takes charge\nand delegates tasks as required. This central person also plays a key role in\ndocumenting the happenings in the war room — how many people were present, which\nteams were represented, who was handling what, etc. All this information plays a\nkey role in the RCA. While this is going down, Driver and Customer Care centres\nare also notified, bracing for the inevitable flurry of complaints.\n\nThe fix may take the form of a few simple temporary hacks, or an hours long war\nroom — but in the end, there is always a fix.\n\nWords of appreciation from GoPay CEO Aldi Haryopratomo and Gojek CTO Ajey Gore\nAnd a sense of camaraderie ?\n\nOnce the dust settles, the investigation begins. The person who managed the war\nroom generally authors a document analysing what went wrong, using all the info\nfrom the alerts, dashboards, and firsthand accounts of the responders present.\nTypically every stakeholder in the organisation gets an email the next day with\ndetails of what went wrong — the RCA.\n\n5. The Learnings\n“Collaborate With Compassion”\n\nThese three words mean a lot at Gojek, and our RCAs reflect that. When you open\nan RCA mail, there is rarely even a mention of specific people, except to\nacknowledge those who responded to the distress call and played a role in\nfinding a fix. Call out the ones who made the effort, never the ones\nresponsible.\n\nMost RCAs instead dwell on relevant, actionable information. Information that\nwas being collected and monitored right from when the alert tripped:\n\nThe What: What was the problem?\n\nThe Why: Why did it happen?\n\nThe Fallout: Which services were affected, and for how long?\n\nThe Response: How was it fixed?\n\nThe Learnings: What can be done to avoid a repeat of this in future?\n\nThis simple process has helped us scale more safely and efficiently. It also\nallows for early identification of potential vulnerabilities in other systems.\nAs you may have noticed, there is no mention of who was responsible, no finger\npointing, no blame games. Collaborate with compassion.\n\nTo get a better sense of how we write RCAs at Gojek, read a sample RCA\n[https://docs.google.com/document/d/1r_PSsl7mBxbfAcibGTdFpnM5hm6ot82bF-_9VeV2J9w/edit?ts=5db7c330#heading=h.kreykp6cjau6]\n.\n\nIf you’d like to start a culture of RCAs as well, here’s our RCA template\n[https://docs.google.com/document/d/12Ims21IwFCNWi9MXcw2TVxPLB6YyWrIoTNaw3P-M_t4/edit]\n, courtesy GoPay CTO Ranjan Sakalley [https://twitter.com/rnjn], who also\noccasionally drops invaluable insights in the ‘Learnings’ section. ?\n\n\nRCAs have played an integral part in our journey to becoming a SuperApp.\nInvestigating, analysing, and documenting problems in production help us build\nbetter, more scalable systems, and tackle new problems in a mature manner\nwithout fear of retribution.\n\nThe days of weekly production issues are now a thing of the past. While we won’t\nbe so brash as to say we never have problems, embracing RCAs and a culture of\ncompassionate collaboration have helped us get to where we are today. ?\n\n\n--------------------------------------------------------------------------------\n\nWe’ll be writing about more interesting case studies on issues faced in\nproduction. Keep an eye on this blog, or subscribe to our newsletter\n[https://mailchi.mp/go-jek/gojek-tech-newsletter] for updates on our stories in\na neat little email.","html":"<p>When Gojek was still finding its feet, Fridays used to be a nightmare.</p><p>Jakarta, being the capital of the fourth most-populous country in the world, is home to many people who work in the city and travel to their hometowns on weekends. Many of them rely on Gojek as their preferred first mile connectivity option — resulting in a traffic spike on our systems on Friday evening. In those early days, this often triggered a system outage.</p><p><em><em>Every outage erodes the hard earned trust we build with our customers and driver partners.</em></em></p><h1 id=\"enter-the-rca\">Enter the RCA</h1><p>We knew we couldn’t fix the failures overnight, but we could learn from them. After all, so many of these mistakes were common and easily overlooked. So we decided to embrace the ‘Root Cause Analysis’ (RCA). If something related to Gojek’s Engineering division failed, the person(s) who attended the support call and had most context of what happened would prepare a document. This document would contain a timeline, detail what went wrong, suggest corrective measures, and compile lessons learned.</p><p>This process ensured everyone across the organisation had visibility into what happened. As a result, even unaffected teams cited in the RCA could analyse their systems to ensure the same problem would not happen to them. More importantly, it provided a degree of accountability — and that’s important when you have 20+ products.</p><p>A post-mortem, and a prevention.</p><p>This post details what happens when a system failure happens at Gojek, and how it makes it way into an RCA.</p><h2 id=\"1-the-what\">1. The What</h2><p>When something fails, it is important to understand the origin of the problem. Every team in Gojek sets up alerts which monitor the state of their systems. If a state change in the system causes a deviation from expected behaviour, an alerting service called <code>pager duty</code> automatically dials the phones of the people responsible for that part of the system.</p><p><strong><strong>Here’s an example:</strong></strong></p><p>When a booking is created, we find a list of driver partners and send the order details to them, at which point they get a pop-up with trip details like estimated duration and approximate earnings. The idea is to give driver partners enough information to make the decision to accept the trip. But there was a problem.</p><h2 id=\"2-the-why\">2. The Why</h2><p>One of the fields this prompt contains is a Booking ID, which is stored as an integer (which, in technical speak, has a limit of 32 bits). Unfortunately for us, the ID generated exceeded this limit.</p><p>Welcome to what we call Integer Overflow.</p><p>As a result of this, the driver app started crashing.</p><p><strong><strong><em><em>How bad can that be, you ask?</em></em></strong></strong></p><h2 id=\"3-the-fallout\">3. The Fallout</h2><p>Drivers being unable to use the app means they can’t accept bookings. This means customers can’t book rides, send packages, get food, or use any service that depends on our driver partners.</p><p>As a result, Gojek’s order numbers (or what we call ‘concurrence’, if you want to get all technical about it) plummeted. Pager duty is hit, and cell phones start ringing off their proverbial hooks.</p><p>With driver partners stuck with malfunctioning apps, multiple Gojek services start reporting errors. As customers try and figure out why the app is behaving this way, engineers scramble to do the same.</p><h2 id=\"4-the-response\">4. The Response</h2><p>When the phones ring, the team whose alerts have been triggered immediately get to work figuring out what happened. If they identify the problem quickly and debug it, they notify other teams. The team then gets to work using information from the alerts and system dashboards to prepare an RCA.</p><p><strong><strong>This is, of course, the best case scenario.</strong></strong></p><p>If the concerned team cannot find a fix however, a war room is called.</p><p>The war room signifies a larger issue, and members of every available team drop what they’re doing and join the call. Sometimes, these are frantic Slack discussions and calls in the middle of the night. Other times, office boardrooms are blocked and everyone gathers to brainstorm collectively.</p><p><em><em>Devs, Team Leads, Product Managers, all hands on deck.</em></em></p><p>In a war room scenario, whoever has most context on the situation takes charge and delegates tasks as required. This central person also plays a key role in documenting the happenings in the war room — <strong><strong>how many people were present, which teams were represented, who was handling what, etc.</strong></strong> <strong><strong>All this information plays a key role in the RCA.</strong></strong> While this is going down, Driver and Customer Care centres are also notified, bracing for the inevitable flurry of complaints.</p><p>The fix may take the form of a few simple temporary hacks, or an hours long war room — but in the end, there is always a fix.</p><figure class=\"kg-card kg-image-card kg-width-wide kg-card-hascaption\"><img src=\"https://miro.medium.com/max/1129/1*UFUYfO3Gw9tnKCiE1y40-Q.jpeg\" class=\"kg-image\"><figcaption>Words of appreciation from GoPay CEO Aldi Haryopratomo and Gojek CTO Ajey Gore</figcaption></figure><p><em><em>And a sense of camaraderie ?</em></em></p><p>Once the dust settles, the investigation begins. The person who managed the war room generally authors a document analysing what went wrong, using all the info from the alerts, dashboards, and firsthand accounts of the responders present. Typically every stakeholder in the organisation gets an email the next day with details of what went wrong — the RCA.</p><h2 id=\"5-the-learnings\">5. The Learnings</h2><p>“Collaborate With Compassion”</p><p>These three words mean a lot at Gojek, and our RCAs reflect that. When you open an RCA mail, there is rarely even a mention of specific people, except to acknowledge those who responded to the distress call and played a role in finding a fix. <strong><strong>Call out the ones who made the effort, never the ones responsible.</strong></strong></p><p>Most RCAs instead dwell on relevant, actionable information. Information that was being collected and monitored right from when the alert tripped:</p><p><em><em>The What: What was the problem?</em></em></p><p><em><em>The Why: Why did it happen?</em></em></p><p><em><em>The Fallout: Which services were affected, and for how long?</em></em></p><p><em><em>The Response: How was it fixed?</em></em></p><p><em><em>The Learnings: What can be done to avoid a repeat of this in future?</em></em></p><p>This simple process has helped us scale more safely and efficiently. It also allows for early identification of potential vulnerabilities in other systems. As you may have noticed, there is no mention of who was responsible, no finger pointing, no blame games. <em><em>Collaborate with compassion.</em></em></p><p>To get a better sense of how we write RCAs at Gojek, <a href=\"https://docs.google.com/document/d/1r_PSsl7mBxbfAcibGTdFpnM5hm6ot82bF-_9VeV2J9w/edit?ts=5db7c330#heading=h.kreykp6cjau6\" rel=\"noopener\"><strong><strong>read a sample RCA</strong></strong></a>.</p><p>If you’d like to start a culture of RCAs as well, <a href=\"https://docs.google.com/document/d/12Ims21IwFCNWi9MXcw2TVxPLB6YyWrIoTNaw3P-M_t4/edit\" rel=\"noopener\"><strong><strong>here’s our RCA template</strong></strong></a>, courtesy GoPay CTO <a href=\"https://twitter.com/rnjn\" rel=\"noopener\">Ranjan Sakalley</a>, who also occasionally drops invaluable insights in the ‘Learnings’ section. <strong><strong>?</strong></strong><br></p><figure class=\"kg-card kg-image-card\"><img src=\"https://miro.medium.com/max/480/1*2sosYEnk68lMaQTVjdZjWQ.jpeg\" class=\"kg-image\"></figure><p>RCAs have played an integral part in our journey to becoming a SuperApp. Investigating, analysing, and documenting problems in production help us build better, more scalable systems, and tackle new problems in a mature manner without fear of retribution.</p><p>The days of weekly production issues are now a thing of the past. While we won’t be so brash as to say we never have problems, embracing RCAs and a culture of compassionate collaboration have helped us get to where we are today. ?</p><hr><p>We’ll be writing about more interesting case studies on issues faced in production. Keep an eye on this blog, or <a href=\"https://mailchi.mp/go-jek/gojek-tech-newsletter\" rel=\"noopener\">subscribe to our newsletter</a> for updates on our stories in a neat little email.</p>","url":"https://gojek-ghost.zysk.in/why-we-swear-by-the-rca/","canonical_url":null,"uuid":"ef04187f-7199-434a-8647-6dcd386043cd","page":null,"codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5eb1066a5524cd001e7392a4","reading_time":5}},{"node":{"id":"Ghost__Post__5eafa30734df85001e15f489","title":"How We Pushed a Million Keys to Redis in Seconds","slug":"how-we-pushed-a-million-keys-to-redis-in-seconds","featured":false,"feature_image":"https://res-2.cloudinary.com/hcq4cvthp/image/upload/q_auto/v1/ghost-blog-images/1_gN5KGQcKSipjSlQqEppJMA.jpg","excerpt":"Dealing with a lot of keys? Redis’ Pipe Mode is your friend.\nHello there!\n\nIn this post, I’ll share my ideas on how we populated Redis (running in a\nKubernetes cluster)… in a matter of seconds.\n\nHere’s what can you expect from this post:\n\n1. How to connect to Redis server running in a Kubernetes cluster ?\n\n2. What is Port-forwarding ?\n\n3. How to use Redis mass insertion & push millions of keys in seconds ?\n\n4. How to generate Redis Protocol ?\n\n5. How to read /parse a CSV in Ruby ?\n\nWait, but why","custom_excerpt":null,"visibility":"public","created_at_pretty":"04 May, 2020","published_at_pretty":"04 May, 2020","updated_at_pretty":"12 May, 2020","created_at":"2020-05-04T10:37:19.000+05:30","published_at":"2020-05-04T10:45:13.000+05:30","updated_at":"2020-05-12T11:50:45.000+05:30","meta_title":"How We Pushed a Million Keys to Redis in Seconds","meta_description":"Dealing with a lot of keys? Redis’ Pipe Mode is your friend.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Gojek","slug":"gojek","bio":"Gojek is a Super App. It’s one app for ordering food, commuting, digital payments, shopping, hyper-local delivery, and two dozen services.","profile_image":"https://gojek-ghost.zysk.in/content/images/2020/05/logo-01-1.png","twitter":"@gojektech","facebook":"gojektech","website":"https://www.gojek.io"}],"primary_author":{"name":"Gojek","slug":"gojek","bio":"Gojek is a Super App. It’s one app for ordering food, commuting, digital payments, shopping, hyper-local delivery, and two dozen services.","profile_image":"https://gojek-ghost.zysk.in/content/images/2020/05/logo-01-1.png","twitter":"@gojektech","facebook":"gojektech","website":"https://www.gojek.io"},"primary_tag":{"name":"Tech","slug":"tech","description":"Learnings from technical challenges solved at Gojek, how-tos, and programming tips.","feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Tech","slug":"tech","description":"Learnings from technical challenges solved at Gojek, how-tos, and programming tips.","feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Dealing with a lot of keys? Redis’ Pipe Mode is your friend.\nHello there!\n\nIn this post, I’ll share my ideas on how we populated Redis (running in a\nKubernetes cluster)… in a matter of seconds.\n\nHere’s what can you expect from this post:\n\n1. How to connect to Redis server running in a Kubernetes cluster ?\n\n2. What is Port-forwarding ?\n\n3. How to use Redis mass insertion & push millions of keys in seconds ?\n\n4. How to generate Redis Protocol ?\n\n5. How to read /parse a CSV in Ruby ?\n\nWait, but why do I need to do this? ?\n\nAt Gojek, we use Redis in one of the services for caching drivers for faster\nlookups. Since we have deployed this service to new clusters, we needed to\npopulate Redis with ~81K keys.\n\nWhat we didn’t do (and should not be done)\nWell, this. ?\n\n$ redis-cli -h \"hostname\" -p 6379 set \"key\" \"value\"\n\nThis simple and easy way of storing a key through redis-cli\n[https://redis.io/topics/rediscli] is okay, but not for thousands or millions of\nkeys. You don’t want to end up waiting for hours unless you are Regina Phalange\n[https://en.wikipedia.org/wiki/Phoebe_Buffay#%22Regina_Phalange%22]! ?\n\nUsing a normal Redis client to perform mass insertion is not a good idea. The\nnaive approach of sending one command after the other is slow, because you have\nto pay for the round trip time for every command.\n\nLet’s do something different!\nWe will use Redis mass insertion, but before going to that, let’s talk a bit\nabout Redis Protocol [https://redis.io/topics/protocol].\n\nRedis clients communicate with the Redis server using a protocol called RESP \n(REdis Serialization Protocol).\n\nWith that said, let’s go write some code! I like toying around with Ruby\n[https://www.ruby-lang.org/en/], so this was my language of choice.\n\nredis_mass_insert.rbgen_redis_proto function will generate the protocol required for mass insertion.\n\n> 2.6.3 > puts gen_redis_proto(\"SET\",\"mykey\",\"Hello World!\").inspect\nRunning the above command in Ruby console, will give us the following protocol.\n\n\"*3\\r\\n$3\\r\\nSET\\r\\n$5\\r\\nmykey\\r\\n$12\\r\\nHello World!\\r\\n\"\n\nWell, this is how a command is represented and sent to the Redis Server through \nRedis Protocol [https://redis.io/topics/protocol].\n\n*<args><cr><lf>\n$<len><cr><lf>\n<arg0><cr><lf>\n<arg1><cr><lf>\n...\n<argN><cr><lf>\n\nWhere <cr> means \"\\r\" (or ASCII character 13) and <lf> means \"\\n\" (or ASCII\ncharacter 10).\n\nWe can now run this script, but here’s a catch. Our Redis server runs in a\nKubernetes cluster and we didn’t want to install Ruby and its gems inside a\ncluster. So now?\n\nEnter port-forwarding! ?\n$ kubectl -n \"namespace\" port-forward \"pod-name\" 7000:6379\n\nConnections made to local port 7000 are forwarded to port 6379 of the pod that\nis running the Redis server. With this connection in place we can use our local\nworkstation to debug the database that is running in the pod.\n\nFinally, we run our script to populate Redis ?\n\n> $ ruby redis_mass_insert.rb | redis-cli -p 7000 --pipe\n> All data transferred. Waiting for the last reply...\nLast reply received from server.\nerrors: 0, replies: 81003\nWe ran this script and it completed within a fraction of seconds!\n\nBut, how?\nIn 2.6 or later versions of Redis the redis-cli utility supports a new mode\ncalled pipe mode that was designed in order to perform mass insertion.\n\nUnder the hood of pipe mode\nAccording to the official doc:\n\n * redis-cli — pipe tries to send data as fast as possible to the server.\n * At the same time it reads data when available, trying to parse it.\n * Once there is no more data to read from stdin, it sends a special ECHO \n   command with a random 20 bytes string: we are sure this is the latest command\n   sent, and we are sure we can match the reply checking if we receive the same\n   20 bytes as a bulk reply.\n * Once this special final command is sent, the code receiving replies starts to\n   match replies with these 20 bytes. When the matching reply is reached it can\n   exit with success.\n\nNaice, what’s next?\nWell, I tried populating Redis locally with a million keys.\n\nIt worked like a charm, in just ~2 seconds. ?\n\nThat’s it!\nI really hope that this post gave you some new insights.\n\nThanks for reading! ?\n\nReferences\n\n 1. Redis Mass Insertion [https://redis.io/topics/mass-insert]\n 2. Redis Protocol [https://redis.io/topics/protocol]\n 3. Port Forwarding in Kubernetes to access applications\n    [https://kubernetes.io/docs/tasks/access-application-cluster/port-forward-access-application-cluster/]\n\nWant our stories to land in your inbox? Sign up for our newsletter!\n[https://mailchi.mp/go-jek/gojek-tech-newsletter]","html":"<h3 id=\"dealing-with-a-lot-of-keys-redis-pipe-mode-is-your-friend-\">Dealing with a lot of keys? Redis’ Pipe Mode is your friend.</h3><p>Hello there!</p><p>In this post, I’ll share my ideas on how we populated Redis (running in a Kubernetes cluster)… in a matter of seconds.</p><p>Here’s what can you expect from this post:</p><p><em><em>1. How to connect to Redis server running in a Kubernetes cluster ?</em></em></p><p><em><em>2. What is Port-forwarding ?</em></em></p><p><em><em>3. How to use Redis mass insertion &amp; push millions of keys in seconds ?</em></em></p><p><em><em>4. How to generate Redis Protocol ?</em></em></p><p><em><em>5. How to read /parse a CSV in Ruby ?</em></em></p><p>Wait, but why do I need to do this? ?</p><p>At Gojek, we use Redis in one of the services for caching drivers for faster lookups. Since we have deployed this service to new clusters, we needed to populate Redis with ~81K keys.</p><h2 id=\"what-we-didn-t-do-and-should-not-be-done-\">What we didn’t do (and should not be done)</h2><p>Well, this. ?</p><p><code>$ redis-cli -h \"hostname\" -p 6379 set \"key\" \"value\"</code></p><p>This simple and easy way of storing a key through <code><a href=\"https://redis.io/topics/rediscli\" rel=\"noopener\">redis-cli</a></code> is okay, but not for thousands or millions of keys. You don’t want to end up waiting for hours unless you are <a href=\"https://en.wikipedia.org/wiki/Phoebe_Buffay#%22Regina_Phalange%22\" rel=\"noopener\">Regina Phalange</a>! ?</p><figure class=\"kg-card kg-embed-card\"><iframe src=\"https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fgiphy.com%2Fembed%2F5xaOcLvROln5TmaaVOM%2Ftwitter%2Fiframe&amp;display_name=Giphy&amp;url=https%3A%2F%2Fgiphy.com%2Fgifs%2Fthecomebackhbo-comeback-the-val-cherish-5xaOcLvROln5TmaaVOM&amp;image=https%3A%2F%2Fmedia.giphy.com%2Fmedia%2F5xaOcLvROln5TmaaVOM%2Fgiphy.gif&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=giphy\" allowfullscreen=\"\" frameborder=\"0\" height=\"301\" width=\"435\" title=\"Lisa Kudrow Thank You GIF by The Comeback HBO - Find &amp; Share on GIPHY\" class=\"s t u iu ai\" scrolling=\"auto\" style=\"box-sizing: inherit; position: absolute; top: 0px; left: 0px; width: 680px; height: 470.516px;\"></iframe></figure><p>Using a normal Redis client to perform mass insertion is not a good idea. The naive approach of sending one command after the other is slow, because you have to pay for the round trip time for every command.</p><h1 id=\"let-s-do-something-different-\">Let’s do something different!</h1><p>We will use Redis mass insertion, but before going to that, let’s talk a bit about <a href=\"https://redis.io/topics/protocol\" rel=\"noopener\">Redis Protocol</a>.</p><p><em><em>Redis clients communicate with the Redis server using a protocol called <strong><strong>RESP</strong></strong> (REdis Serialization Protocol).</em></em></p><p>With that said, let’s go write some code! I like toying around with <a href=\"https://www.ruby-lang.org/en/\" rel=\"noopener\">Ruby</a>, so this was my language of choice.</p><figure class=\"kg-card kg-embed-card kg-card-hascaption\"><iframe src=\"https://blog.gojekengineering.com/media/59319951b0d29feee60832a68f811a18\" allowfullscreen=\"\" frameborder=\"0\" height=\"364\" width=\"680\" title=\"Ruby Script for Redis Mass Insertion\" class=\"s t u iu ai\" scrolling=\"auto\" style=\"box-sizing: inherit; position: absolute; top: 0px; left: 0px; width: 680px; height: 364px;\"></iframe><figcaption>redis_mass_insert.rb</figcaption></figure><p><code>gen_redis_proto</code> function will generate the protocol required for mass insertion.</p><blockquote>2.6.3 &gt; <strong><strong>puts gen_redis_proto(\"SET\",\"mykey\",\"Hello World!\").inspect</strong></strong></blockquote><p>Running the above command in Ruby console, will give us the following protocol.</p><p><code>\"*3\\r\\n$3\\r\\nSET\\r\\n$5\\r\\nmykey\\r\\n$12\\r\\nHello World!\\r\\n\"</code></p><p>Well, this is how a command is represented and sent to the Redis Server through <a href=\"https://redis.io/topics/protocol\" rel=\"noopener\">Redis Protocol</a>.</p><p><code>*&lt;args&gt;&lt;cr&gt;&lt;lf&gt;<br>$&lt;len&gt;&lt;cr&gt;&lt;lf&gt;<br>&lt;arg0&gt;&lt;cr&gt;&lt;lf&gt;<br>&lt;arg1&gt;&lt;cr&gt;&lt;lf&gt;<br>...<br>&lt;argN&gt;&lt;cr&gt;&lt;lf&gt;</code></p><p><em><em>Where <code>&lt;cr&gt;</code> means \"\\r\" (or ASCII character 13) and <code>&lt;lf&gt;</code> means \"\\n\" (or ASCII character 10).</em></em></p><p>We can now run this script, but here’s a catch. Our Redis server runs in a Kubernetes cluster and we didn’t want to install Ruby and its gems inside a cluster. So now?</p><h1 id=\"enter-port-forwarding-\">Enter port-forwarding! ?</h1><p><strong><strong><code>$ kubectl -n \"namespace\" port-forward \"pod-name\" 7000:6379</code></strong></strong></p><p>Connections made to local port 7000 are forwarded to port 6379 of the pod that is running the Redis server. With this connection in place we can use our local workstation to debug the database that is running in the pod.</p><p><em><em><em>Finally, we run our script to populate Redis ?</em></em></em></p><blockquote><strong><strong>$ ruby redis_mass_insert.rb | redis-cli -p 7000 --pipe</strong></strong></blockquote><blockquote>All data transferred. Waiting for the last reply...<br>Last reply received from server.<br>errors: 0, replies: 81003</blockquote><p>We ran this script and it completed within a fraction of seconds!</p><figure class=\"kg-card kg-embed-card\"><iframe src=\"https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fgiphy.com%2Fembed%2FjRARA4zqym98KmvkUy%2Ftwitter%2Fiframe&amp;display_name=Giphy&amp;url=https%3A%2F%2Fgiphy.com%2Fgifs%2FjRARA4zqym98KmvkUy&amp;image=https%3A%2F%2Fmedia.giphy.com%2Fmedia%2FjRARA4zqym98KmvkUy%2Fgiphy.gif&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=giphy\" allowfullscreen=\"\" frameborder=\"0\" height=\"246\" width=\"435\" title=\"Bingo GIF - Find &amp; Share on GIPHY\" class=\"s t u iu ai\" scrolling=\"auto\" style=\"box-sizing: inherit; position: absolute; top: 0px; left: 0px; width: 680px; height: 384.547px;\"></iframe></figure><h1 id=\"but-how\">But, how?</h1><p>In 2.6 or later versions of Redis the <code>redis-cli</code> utility supports a new mode called <strong><strong>pipe mode</strong></strong> that was designed in order to perform mass insertion.</p><h2 id=\"under-the-hood-of-pipe-mode\">Under the hood of pipe mode</h2><p>According to the official doc:</p><ul><li><em><em>redis-cli — pipe tries to send data as fast as possible to the server.</em></em></li><li><em><em>At the same time it reads data when available, trying to parse it.</em></em></li><li><em><em>Once there is no more data to read from stdin, it sends a special </em></em><strong><strong><em><em>ECHO</em></em></strong></strong><em><em> command with a random 20 bytes string: we are sure this is the latest command sent, and we are sure we can match the reply checking if we receive the same 20 bytes as a bulk reply.</em></em></li><li><em><em>Once this special final command is sent, the code receiving replies starts to match replies with these 20 bytes. When the matching reply is reached it can exit with success.</em></em></li></ul><h1 id=\"naice-what-s-next\">Naice, what’s next?</h1><p>Well, I tried populating Redis locally with <em><em>a million keys.</em></em></p><p>It worked like a charm, in just ~2 seconds. ?</p><figure class=\"kg-card kg-embed-card\"><iframe src=\"https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fgiphy.com%2Fembed%2Fj6ZQKMy3W3629lDJSX%2Ftwitter%2Fiframe&amp;display_name=Giphy&amp;url=https%3A%2F%2Fgiphy.com%2Fgifs%2Fhbo-avenue-5-avenue5-j6ZQKMy3W3629lDJSX&amp;image=https%3A%2F%2Fmedia.giphy.com%2Fmedia%2Fj6ZQKMy3W3629lDJSX%2Fgiphy.gif&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=giphy\" allowfullscreen=\"\" frameborder=\"0\" height=\"244\" width=\"435\" title=\"Hugh Laurie Charm GIF by HBO - Find &amp; Share on GIPHY\" class=\"s t u iu ai\" scrolling=\"auto\" style=\"box-sizing: inherit; position: absolute; top: 0px; left: 0px; width: 680px; height: 381.422px;\"></iframe></figure><h1 id=\"that-s-it-\">That’s it!</h1><p>I really hope that this post gave you some new insights.</p><p>Thanks for reading! ?</p><p><strong><strong>References</strong></strong></p><ol><li><a href=\"https://redis.io/topics/mass-insert\" rel=\"noopener\">Redis Mass Insertion</a></li><li><a href=\"https://redis.io/topics/protocol\" rel=\"noopener\">Redis Protocol</a></li><li><a href=\"https://kubernetes.io/docs/tasks/access-application-cluster/port-forward-access-application-cluster/\" rel=\"noopener\">Port Forwarding in Kubernetes to access applications</a></li></ol><figure class=\"kg-card kg-image-card\"><img src=\"https://miro.medium.com/max/60/1*Yigf1nGxRKjzV7vIC_YkYg.png?q=20\" class=\"kg-image\"></figure><p>Want our stories to land in your inbox? <a href=\"https://mailchi.mp/go-jek/gojek-tech-newsletter\" rel=\"noopener\">Sign up for our newsletter!</a></p>","url":"https://gojek-ghost.zysk.in/how-we-pushed-a-million-keys-to-redis-in-seconds/","canonical_url":null,"uuid":"399d0acb-04ee-4db6-8925-35c9dd3533e5","page":null,"codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5eafa30734df85001e15f489","reading_time":3}}]}},"pageContext":{"slug":"how-we-pushed-a-million-keys-to-redis-in-seconds"}}}